type FilterNameFieldType {
  id: ID!
  name: String
}

type FilterLabelFieldType {
  id: ID!
  label: String
}

type PictureType {
  baseUrl: String
  path: String
  width: Int
  height: Int
  x: Int
  y: Int
  alt: String
}

type NestedPicturesType {
  cover: PictureType
  profile: PictureType
}

type CountryType {
  id: ID!
  name: String!
  code: String
  dialCode: String
  flagSquare: PictureType
  flagWide: PictureType
  iconFlag: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

# A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
scalar DateTime

type CountryPaginatedType {
  count: Int
  isLast: Boolean
  objects: [CountryType!]!
}

type DeleteResponseDtoType {
  message: String!
  success: Boolean!
}

type StateType {
  id: ID!
  name: String!
  created: DateTime!
  surface: String!
  code: String
  dialCode: String
  flagSquare: PictureType
  flagWide: PictureType
  country: CountryType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type StatePaginatedType {
  count: Int
  isLast: Boolean
  objects: [StateType!]!
}

type LanguageType {
  id: ID!
  name: String!
  code: String
  flagSquare: PictureType
  flagWide: PictureType
  iconFlag: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type LanguagePaginatedType {
  count: Int
  isLast: Boolean
  objects: [LanguageType!]!
}

type SocialImagesImagesSetType {
  size48: PictureType
  size96: PictureType
  size144: PictureType
  size240: PictureType
  size480: PictureType
}

type SocialImagesImagesType {
  svg: SocialImagesImagesSetType
  png: SocialImagesImagesSetType
}

type SocialImagesType {
  style: SocialImageStyleEnum!
  images: [SocialImagesImagesType!]
}

enum SocialImageStyleEnum {
  BUBBLE
  COLOR
  STICKER
  COLOR_HAND_DROWN
}

type SocialType {
  id: ID!
  name: String!
  code: String
  fontIcon: String
  images: [SocialImagesType!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

type SocialPaginatedType {
  count: Int
  isLast: Boolean
  objects: [SocialType!]!
}

type PaymentImagesPngType {
  alt: PictureType
  alt2x: PictureType
  alt_128: PictureType
  alt_256: PictureType
  alt_512: PictureType
  card_flat: PictureType
  card_flat2x: PictureType
  card_flat_128: PictureType
  card_flat_256: PictureType
  card_flat_512: PictureType
  dark: PictureType
  dark2x: PictureType
  dark_128: PictureType
  dark_256: PictureType
  dark_512: PictureType
  flat: PictureType
  flat2x: PictureType
  flat_128: PictureType
  flat_256: PictureType
  flat_512: PictureType
  light: PictureType
  light2x: PictureType
  light_128: PictureType
  light_256: PictureType
  light_512: PictureType
  default: PictureType
  default2x: PictureType
  default_128: PictureType
  default_256: PictureType
  default_512: PictureType
}

type PaymentImagesSvgType {
  alt: PictureType
  card_flat: PictureType
  dark: PictureType
  flat: PictureType
  light: PictureType
  default: PictureType
}

type PaymentImagesType {
  svg: PaymentImagesSvgType
  png: PaymentImagesPngType
}

type PaymentType {
  id: ID!
  name: String!
  code: String
  paymentType: PaymentTypeEnum
  materialIcon: String
  images: PaymentImagesType
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum PaymentTypeEnum {
  CREDIT_CARD
  PAYMENT
  METHODS
}

type PaymentPaginatedType {
  count: Int
  isLast: Boolean
  objects: [PaymentType!]!
}

type GlobalCategoryType {
  id: ID!
  identifier: Int!
  name: String!
  provider: GlobalCategoryProviderEnum
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum GlobalCategoryProviderEnum {
  GOOGLE
  FACEBOOK
}

type GlobalCategoryPaginatedType {
  count: Int
  isLast: Boolean
  objects: [GlobalCategoryType!]!
}

type BrowserLogoPngType {
  default: PictureType
  size16: PictureType
  size24: PictureType
  size32: PictureType
  size48: PictureType
  size64: PictureType
  size128: PictureType
  size256: PictureType
  size512: PictureType
}

type BrowserLogoType {
  svg: PictureType
  png: BrowserLogoPngType
  icon: String
}

type BrowserType {
  id: ID!
  name: String
  tags: [String!]
  code: String!
  logo: BrowserLogoType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type BrowserPaginatedType {
  count: Int
  isLast: Boolean
  objects: [BrowserType!]!
}

type DeviceBrandLogoPngType {
  default: PictureType
  size16: PictureType
  size24: PictureType
  size32: PictureType
  size48: PictureType
  size64: PictureType
  size128: PictureType
  size256: PictureType
  size512: PictureType
}

type DeviceBrandLogoType {
  svg: PictureType
  png: DeviceBrandLogoPngType
  icon: String
}

type TechDeviceBrandType {
  id: ID!
  name: String!
  code: String
  tags: [String!]
  logo: DeviceBrandLogoType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type TechDeviceBrandPaginatedType {
  count: Int
  isLast: Boolean
  objects: [TechDeviceBrandType!]!
}

type TechDeviceSpecsType {
  technology: String
  band2g: String
  gprs: String
  edge: String
  announced: String
  status: String
  dimensions: String
  weight: String
  sim: String
  type: String
  size: String
  resolution: String
  cardSlot: String
  phonebook: String
  callRecords: String
  loudspeaker: String
  alertTypes: String
  jack35mm: String
  wlan: String
  bluetooth: String
  gps: String
  radio: String
  usb: String
  sensors: String
  messaging: String
  browser: String
  clock: String
  alarm: String
  games: String
  languages: String
  java: String
  colors: String
}

type TechDeviceType {
  id: ID!
  name: String
  tags: [String!]
  code: String
  picture: PictureType
  releasedat: String
  body: String
  os: String
  storage: String
  displaySize: String
  displayResolution: String
  cameraPixels: String
  videoPixels: String
  ram: String
  chipset: String
  batterySize: String
  batteryType: String
  specifications: TechDeviceSpecsType
  brand: TechDeviceBrandType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type TechDevicePaginatedType {
  count: Int
  isLast: Boolean
  objects: [TechDeviceType!]!
}

type TechDeviceTypeType {
  id: ID!
  name: String
  tags: [String!]
  nodeName: String
  code: String
  pictureSquare: PictureType
  pictureWide: PictureType
  icon: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type TechDeviceTypePaginatedType {
  count: Int
  isLast: Boolean
  objects: [TechDeviceTypeType!]!
}

type OSLogoPngType {
  default: PictureType
  size16: PictureType
  size24: PictureType
  size32: PictureType
  size48: PictureType
  size64: PictureType
  size128: PictureType
}

type OSLogoType {
  svg: PictureType
  png: OSLogoPngType
  icon: String
}

type OperatingSystemType {
  id: ID!
  name: String!
  code: String
  tags: [String!]
  slug: String
  logo: OSLogoType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type OperatingSystemPaginatedType {
  count: Int
  isLast: Boolean
  objects: [OperatingSystemType!]!
}

type PluginPicturesType {
  square: PictureType
  wide: PictureType
}

type PluginType {
  id: ID!
  name: String!
  description: String
  code: String
  cost: String
  url: String
  info: String
  category: String
  pictures: PluginPicturesType
  icon: String
  recommended: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type LonLatType {
  type: String
  coordinates: [Float!]
}

type FullAddressOwnerPhoneType {
  number: String
  countryCode: String
}

type FullAddressOwnerType {
  name: String
  phone: FullAddressOwnerPhoneType
}

type FullAddressType {
  owner: FullAddressOwnerType
  address: String
  postCode: String
  city: String
  country: CountryType
  state: StateType
  addressLine: String
  location: LonLatType
}

type BankType {
  id: ID!
  name: String!
  code: String
  bic: String
  address: FullAddressType
  logo: BrowserLogoType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type BankPaginatedType {
  count: Int
  isLast: Boolean
  objects: [BankType!]!
}

type BankDetailsHolderType {
  name: String!
  type: BankDetailsHolderTypeEnum
  address: FullAddressType!
}

enum BankDetailsHolderTypeEnum {
  PRIVATE
  COMPANY
}

type BankDetailsType {
  id: ID!
  account: String!
  iban: String
  bank: BankType!
  holder: BankDetailsHolderType!
  externalId: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type BankDetailsPaginatedType {
  count: Int
  isLast: Boolean
  objects: [BankDetailsType!]!
}

type ContentTypeImageFormatType {
  png: PictureType
  svg: PictureType
}

type ContentTypeImageType {
  background: ContentTypeImageFormatType
  black: ContentTypeImageFormatType
  white: ContentTypeImageFormatType
  icon: String
}

type ContentTypeType {
  id: ID!
  name: String!
  type: String
  image: ContentTypeImageType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type SocialValueType {
  name: SocialType
  value: String
}

type TagType {
  name: String
  content: String
}

type DateRangeType {
  min: DateTime!
  max: DateTime!
}

type PriceRangeType {
  min: String!
  max: String!
}

type GroupType {
  id: ID!
  name: String!
  description: String
  isVerified: Boolean
  picture: NestedPicturesType
  privacy: GroupPrivacyEnum!
  members: [UserType!]!
  moderators: [UserType!]!
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum GroupPrivacyEnum {
  PRIVATE
  PUBLIC
}

type MediaType {
  videos: [String!]
  pictures: [PictureType!]
  deg360: [PictureType!]
}

type IPhoneType {
  number: String
  countryCode: String
}

type PhoneType {
  number: String
  countryCode: String
  isValid: Boolean
  validationNumber: Int
}

type CompanyCustomerType {
  phase: CustomerPhaseEnum
  score: String
}

enum CustomerPhaseEnum {
  LEAD
  CUSTOMER
  TERMINATION
}

type CompanySupplierType {
  kind: SupplierTypeEnum
}

enum SupplierTypeEnum {
  WHOLESALER
  MANUFACTURER
  FRANCHISE
}

type CompanyContactDetailsType {
  website: String
  email: String
  phone: PhoneType
}

type CompanyLegalType {
  vat: String
  register: String
  licence: String
}

type CompanyType {
  id: ID!
  name: String
  description: String
  tags: [String!]
  media: MediaType
  address: FullAddressType
  legal: CompanyLegalType
  banks: [BankDetailsType!]
  contact: CompanyContactDetailsType
  customer: CompanyCustomerType
  supplier: CompanySupplierType
  logistic: Boolean
  target: TargetType
  externalId: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type WholesalerType {
  id: ID!
  name: String
  description: String
  address: FullAddressType
  picture: PictureType
  email: String
  website: String
  phone: IPhoneType
  contactEmails: [String!]
  fax: IPhoneType
  createdAt: DateTime!
  updatedAt: DateTime!
  company: CompanyType
}

type LoyaltyProgramType {
  id: ID!
  programName: String
  picture: PictureType
  company: CompanyType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type POSLoyaltyType {
  loyaltyProgram: LoyaltyProgramType
  from: DateTime!
  to: DateTime!
}

type OpeningHoursDayType {
  day: Days
  from: String
  to: String
}

enum Days {
  MONDAY
  TUESDAY
  WEDNESDAY
  THURSDAY
  FRIDAY
  SATURDAY
  SUNDAY
}

type OpeningHoursType {
  status: OpeningStatus
  hours: [OpeningHoursDayType!]
}

enum OpeningStatus {
  ALWAYS_OPEN
  NOT_AVAILABLE
  SELECTED_HOURS
  PERMANENTLY_CLOSED
}

type SpecialOfferType {
  offerType: SpecialOffersType
  hours: [OpeningHoursDayType!]
}

enum SpecialOffersType {
  BAR
  LUNCH
  BRUNCH
  DINNER
  BREAKFAST
  HAPPY_HOUR
}

type POSCategoryType {
  id: ID!
  name: String
  mapPicture: String
  picture: PictureType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type POSServicesType {
  id: ID
  index: Int
  name: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PointOfSaleType {
  id: ID!
  name: String
  title: String
  subtitle: String
  description: String
  tags: [String!]
  brandColor: String
  reference: String
  published: Boolean
  picture: PictureType
  outsidePictures: [PictureType!]
  insidePictures: [PictureType!]
  openingHours: OpeningHoursType
  specialOffers: [SpecialOfferType!]
  email: [String!]
  contactEmails: [String!]
  currency: Currency
  languages: [LanguageType!]
  phone: [String!]
  website: String
  chatContact: [SocialValueType!]
  socialMedia: [SocialValueType!]
  averageCustomers: Float
  turnover: String
  locations: [FullAddressType!]
  isFollowed: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
  posCategory: [POSCategoryType!]
  company: CompanyType
  services: [POSServicesType!]
  paymentMethods: [PaymentType!]
  loyaltyPrograms: [POSLoyaltyType!]
}

enum Currency {
  EUR
  USD
  TND
}

type ManufacturerType {
  id: ID!
  name: String
  description: String
  picture: PictureType
  externalId: String
  address: FullAddressType
  email: String
  website: String
  contactEmails: [String!]
  createdAt: DateTime!
  updatedAt: DateTime!
  company: CompanyType
}

type StoryContentPositionType {
  left: Float
  right: Float
  top: Float
  bottom: Float
}

type StoryContentDimensionType {
  height: Float
  width: Float
  fontSize: Float
}

type StoryContentContentType {
  content: String
  position: StoryContentPositionType
  dimension: StoryContentDimensionType
  color: String
  contentType: StoriesContentTypeEnum
}

enum StoriesContentTypeEnum {
  GIF
  TEXT
  STICKER
  EMOJI
}

type StoryMediaType {
  picture: PictureType
  video: PictureType
}

type StoriesType {
  id: ID!
  media: StoryMediaType
  seenBy: [UserType!]
  seen: Boolean
  content: [StoryContentContentType!]
  user: UserType
  createdAt: DateTime!
  updatedAt: DateTime!
  pos: PointOfSaleType
  wholesaler: WholesalerType
  manufacturer: ManufacturerType

  # group
  group: GroupType
}

type TargetIdsType {
  # pos id
  pos: ID

  # wholesaler id
  wholesaler: ID

  # manufacturer id
  manufacturer: ID
}

type TargetType {
  # PointOfSale
  pos: PointOfSaleType

  # wholesaler
  wholesaler: WholesalerType

  # manufacturer
  manufacturer: ManufacturerType
}

type TargetWithUserType {
  # PointOfSale
  pos: PointOfSaleType

  # wholesaler
  wholesaler: WholesalerType

  # manufacturer
  manufacturer: ManufacturerType

  # user
  user: UserType
}

type TargetFilterType {
  # PointOfSale
  pos: FilterNameFieldType

  # wholesaler
  wholesaler: FilterNameFieldType

  # manufacturer
  manufacturer: FilterNameFieldType
}

type TargetWithGroupType {
  # PointOfSale
  pos: PointOfSaleType

  # wholesaler
  wholesaler: WholesalerType

  # manufacturer
  manufacturer: ManufacturerType

  # user
  user: UserType

  # group
  group: GroupType
}

type TargetWithGroupAndStoriesType {
  # PointOfSale
  pos: PointOfSaleType

  # wholesaler
  wholesaler: WholesalerType

  # manufacturer
  manufacturer: ManufacturerType

  # user
  user: UserType

  # group
  group: GroupType

  # Stories list
  stories: [StoriesType!]

  # is all Stories are seen
  isAllStoriesSeen: Boolean!
}

type TargetsType {
  # list of pointOfSales
  pos: [PointOfSaleType!]

  # list of wholesalers
  wholesaler: [WholesalerType!]

  # list of manufacturers
  manufacturer: [ManufacturerType!]
}

type TargetPaginateType {
  count: Int
  isLast: Boolean
  objects: [TargetType!]!
}

type DiscountDtoType {
  discountType: DiscountType
  amount: String
}

enum DiscountType {
  AMOUNT
  PERCENTAGE
}

type DocumentResultType {
  doc: String
}

type MetaItemType {
  name: String
  content: String
  property: String
}

type LinkItemType {
  rel: String
  href: String
  type: String
  sizes: String
}

type InvoicePDFType {
  content: String
}

type StringListType {
  list: [String!]
}

type PriceCountType {
  price: String
  count: Float
}

type DifferenceInnerType {
  amount: String
  percentage: String
}

type DifferenceType {
  price: DifferenceInnerType
  count: DifferenceInnerType
}

type CurrentPreviousType {
  current: PriceCountType!
  previous: PriceCountType
  difference: DifferenceType
}

type InstallmentType {
  _id: ID!
  amount: String!
  paymentMethod: PaymentType!
  paymentStatus: PaymentStatusEnum!
  user: UserType
  paidAt: DateTime
  deadline: DateTime
}

enum PaymentStatusEnum {
  OPEN
  PAID
  CANCELED
  REFUNDED
  REFUND_REQUESTED
}

type ProductSpecsType {
  key: String
  value: String
}

type KeyValueListType {
  key: String
  value: String
}

type SuccessResponseDtoType {
  message: String!
  success: Boolean!
}

type OoredooDataType {
  id: String
}

type FacebookDataType {
  id: String!
  token: String!
  email: String!
  name: String
  first_name: String
  last_name: String
}

type GoogleDataType {
  sub: String!
  given_name: String
  name: String
  family_name: String
  picture: String
  email: String!
  token: String!
  locale: String
  email_verified: Boolean
}

type AppleDataType {
  email: String
  status: String
  givenName: String
  familyName: String
  identityToken: String!
  userIdentifier: String
  authorizationCode: String
}

type SocialLoginDataType {
  facebook: FacebookDataType
  google: GoogleDataType
  apple: AppleDataType
  ooredoo: OoredooDataType
}

type UserType {
  id: ID!
  email: String
  picture: PictureType
  pictures: [PictureType!]
  covers: [PictureType!]
  roles: [UserRole!]
  username: String
  firstName: String
  status: UserStatus
  title: String
  about: String
  lastName: String
  apps: [App!]
  maritalStatus: MaritalStatus
  gender: Gender
  languages: [LanguageType!]
  isMailValid: Boolean
  plugged: Boolean
  hasAutoGeneratedEmail: Boolean
  dateOfBirth: DateTime
  phoneNumber: String
  phone: PhoneType
  chatContact: [SocialValueType!]
  socialMedia: [SocialValueType!]
  socialLoginData: SocialLoginDataType
  nationality: CountryType
  locale: String
  placeOfBirth: String
  residentialAddress: [FullAddressType!]
  shippingAddress: [FullAddressType!]
  billingAddress: [FullAddressType!]
  mobileTheme: MobileThemesEnum
  source: SourcesEnum
  newsletterSubs: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum UserRole {
  API
  ADMIN
  EDITOR
  MANAGER
  CONSUMER
  COMMUNITY
  FINANCIAL
  WAREHOUSE
  COMMERCIAL
  MERCHANDISER
  NOT_SPECIFIED
  GROUP_MODERATOR
  WHOLESALER_OWNER
  WHOLESALER_MANAGER
  MANUFACTURER_OWNER
  WHOLESALER_ASSISTANT
  MANUFACTURER_MANAGER
  MANUFACTURER_ASSISTANT
  SALES
  SYSTEM
  CATALOG
  CONTENT
  LOYALTY
  NETWORK
  CUSTOMERS
  INVENTORY
  ORGANIZATION
  MERCHANDISING
  DASHBOARDS_SALES
  DASHBOARDS_FINANCE
  DASHBOARDS_ANALYTICS
  DASHBOARDS_WAREHOUSE
  DASHBOARDS_MERCHANDISING
  POS_OWNER
  POS_WAITER
  POS_MANAGER
  DELIVERY_MAN
  POS_ASSISTANT
}

enum UserStatus {
  ONLINE
  AWAY
  BUSY
  OFFLINE
}

enum App {
  BOSK
  SKUAD
  FIGAMY
  COCKPIT
  DIKTUP
  MAGARI
  RECOLDA
  SIFCA
}

enum MaritalStatus {
  SINGLE
  MARRIED
  ENGAGED
  WIDOWED
  DIVORCED
  SEPERATED
  IN_RELATIONSHIP
  PREFER_NOT_TO_SAY
}

enum Gender {
  MALE
  FEMALE
  PREFER_NOT_TO_SAY
}

enum MobileThemesEnum {
  DARK
  LIGHT
  SYSTEM
}

enum SourcesEnum {
  FIGAMY
  OOREDOO
}

type UserExistType {
  exist: Boolean!
  user: UserType
}

type VapidKeyType {
  vapidKey: String!
}

type IsLoggedInType {
  expired: Boolean!
}

type UserPaginateType {
  count: Int
  isLast: Boolean
  objects: [UserType!]!
}

type LocationType {
  id: ID!
  name: String
  externalId: String
  media: MediaType
  tags: [String!]
  company: CompanyType
  address: FullAddressType
  locationType: LocationTypeEnum
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum LocationTypeEnum {
  OFFICE
  STORAGE
  FACTORY
  WAREHOUSE
}

type LocationPaginateType {
  count: Int
  isLast: Boolean
  objects: [LocationType!]!
}

type WarehouseType {
  id: ID!
  name: String
  media: MediaType
  tags: [String!]
  location: LocationType
  totalSurface: Float
  nonStorageSurface: Float
  externalId: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type WarehousePaginateType {
  count: Int
  isLast: Boolean
  objects: [WarehouseType!]!
}

type LogisticTrackerType {
  status: LogisticStatus
  date: DateTime!
}

enum LogisticStatus {
  PLACED
  PACKED
  OUT_FOR_DELIVERY
  DELIVERED
}

type LogisticType {
  id: ID!
  identifier: String!
  company: CompanyType
  driver: UserType
  tracker: [LogisticTrackerType!]
  warehouse: WarehouseType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type TaxVaType {
  sign: TaxSignEnum!
  value: String
  type: DiscountType!
}

enum TaxSignEnum {
  POSITIVE
  NEGATIVE
}

type TaxType {
  id: ID!
  label: String
  externalId: String
  value: TaxVaType
  use: [TaxUseEnum!]
  product: Boolean
  company: CompanyType
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum TaxUseEnum {
  SALE
  PURCHASE
}

type TaxPaginateType {
  count: Int
  isLast: Boolean
  objects: [TaxType!]!
}

type RentalNoteType {
  return: String
  delivery: String
}

type RentalRefType {
  id: ID!
  location: String
  description: String
  start: DateTime!
  end: DateTime!
  status: RentalStatusEnum
  note: RentalNoteType
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum RentalStatusEnum {
  RETURNED
  DELIVERED
  RETURNING
  DELIVERING
  READY_FOR_PICKUP
}

type DocumentContentType {
  type: ContentTypeType
  base64: String
}

type DocumentType {
  id: ID!
  name: String!
  content: DocumentContentType
  size: Float
  owner: UserType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ProjectMemberType {
  member: UserType
  role: ProjectRoleEnum
}

enum ProjectRoleEnum {
  LEAD
  MEMBER
}

type BoardCardsStatsType {
  total: Int!
  archived: Int!
}

type ProjectType {
  id: ID!
  name: String
  description: String
  media: MediaType
  privacy: ProjectPrivacyEnum
  tags: [String!]
  deadline: DateTime
  priority: ProjectPriorityEnum
  status: ProjectStatusEnum
  color: String
  picture: PictureType
  externalId: String
  members: [ProjectMemberType!]
  resources: [DocumentType!]
  attachments: [DocumentType!]
  target: TargetType
  boardCardsStats: BoardCardsStatsType
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum ProjectPrivacyEnum {
  PRIVATE
  PUBLIC
}

enum ProjectPriorityEnum {
  LOW
  NORMAL
  HIGH
  CRITICAL
}

enum ProjectStatusEnum {
  ACTIVE
  DELIVERED
  BLOCKED
  CANCELLED
}

type StockPixelType {
  quantityToSellOnFacebook: Int
}

type StockRawType {
  id: ID!
  stockCapacity: Int!
  currentStock: Int!
  stockPercentage: String!
  minimumStockQuantity: Int!
  pixel: StockPixelType
  outOfStock: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type StockType {
  id: ID!
  stockCapacity: Int!
  currentStock: Int!
  stockPercentage: String!
  minimumStockQuantity: Int!
  pixel: StockPixelType
  outOfStock: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
  barcode: BarcodeType!
  target: TargetType!
  warehouse: WarehouseType
}

type StockPaginateType {
  count: Int
  isLast: Boolean
  objects: [StockType!]!
}

type MetaKeywordsType {
  name: String
  content: String
}

type CatalogueCategorySeoType {
  urlKey: String
  metaTitle: String
  metaDesription: String
  metaKeywords: [MetaKeywordsType!]
}

type CatalogueCategoryBaseType {
  id: ID!
  name: String
  description: String
  externalId: String
  pictures: [PictureType!]
  variety: ProductVarietyEnum
  parent: CatalogueCategoryBaseType
  portal: Boolean
  pickup: Boolean
  booking: Boolean
  delivery: Boolean
  hasChildren: Boolean!
  rank: Int
  layer: Int!
  seo: CatalogueCategorySeoType
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum ProductVarietyEnum {
  PRODUCT
  EQUIPMENT
  SERVICE
  VEHICULE
}

type CatalogueCategoryType {
  id: ID!
  name: String
  description: String
  externalId: String
  pictures: [PictureType!]
  variety: ProductVarietyEnum
  parent: CatalogueCategoryBaseType
  portal: Boolean
  pickup: Boolean
  booking: Boolean
  delivery: Boolean
  hasChildren: Boolean!
  rank: Int
  layer: Int!
  seo: CatalogueCategorySeoType
  createdAt: DateTime!
  updatedAt: DateTime!
  target: TargetType!
}

type CatalogueCategoryWithChildrenType {
  id: ID!
  name: String
  description: String
  externalId: String
  pictures: [PictureType!]
  variety: ProductVarietyEnum
  parent: CatalogueCategoryBaseType
  portal: Boolean
  pickup: Boolean
  booking: Boolean
  delivery: Boolean
  hasChildren: Boolean!
  rank: Int
  layer: Int!
  seo: CatalogueCategorySeoType
  createdAt: DateTime!
  updatedAt: DateTime!
  target: TargetType!
  children: [CatalogueCategoryWithChildrenType!]
}

type BrandType {
  id: ID
  name: String
  picture: PictureType
  externalId: String
  website: String
  target: TargetType
  manufacturer: ManufacturerType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PriceType {
  id: ID!
  label: String
  enable: Boolean
  company: CompanyType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type AttributeValueBaseType {
  id: ID!
  label: String!
  externalId: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type AttributeValueBaseRawType {
  id: ID!
  label: String!
  externalId: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  attribute: AttributeBaseType!
}

type AttributeValueType {
  id: ID!
  label: String!
  externalId: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  target: TargetType!
  attribute: AttributeType!
}

type AttributeValueFilterType {
  id: ID!
  label: String!
  attribute: AttributeRawBaseType!
}

type AttributeValuePaginateType {
  count: Int
  isLast: Boolean
  objects: [AttributeValueType!]!
}

type AttributePixelType {
  pixelAttribute: String
}

type AttributeRawBaseType {
  id: ID!
  label: String!
}

type AttributeBaseType {
  id: ID!
  label: String!
  externalId: String!
  isRequired: Boolean
  isMultipleChoice: Boolean
  pixel: AttributePixelType
  variety: ProductVarietyEnum
  createdAt: DateTime!
  updatedAt: DateTime!
}

type AttributeWithValueFilterType {
  id: ID!
  label: String
  attributeValues: [FilterLabelFieldType!]
}

type AttributeType {
  id: ID!
  label: String!
  externalId: String!
  isRequired: Boolean
  isMultipleChoice: Boolean
  pixel: AttributePixelType
  variety: ProductVarietyEnum
  createdAt: DateTime!
  updatedAt: DateTime!
  target: TargetType
}

type AttributePaginateType {
  count: Int
  isLast: Boolean
  objects: [AttributeType!]!
}

type ProductAttributeType {
  id: ID!
  attribute: AttributeType!
  isRequired: Boolean!
  isMultipleChoice: Boolean!
  possibleValues: [String!]!
  reference: String!
  target: TargetType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ProductAttributePaginateType {
  count: Int
  isLast: Boolean
  objects: [ProductAttributeType!]!
}

type InventoryCategoryType {
  id: ID!
  name: String!
  picture: PictureType
  layer: Int!
  rank: Int!
  hasChildren: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ProductPriceListType {
  price: PriceType
  value: String
}

type ProductTaxesType {
  tax: TaxType
  rank: Int
}

type ProductType {
  id: ID
  name: String
  externalId: String
  description: String
  descriptionList: [String!]
  specs: [ProductSpecsType!]
  tags: [String!]
  picture: PictureType
  pictures: [PictureType!]
  media: MediaType
  ean: String
  weight: Float
  price: String
  class: [ProductClassEnum!]
  structure: ProductStructureEnum
  rent: Boolean
  variety: ProductVarietyEnum
  wholesalerPrice: String
  factoryPrice: String
  tax: String
  taxes: [ProductTaxesType!]
  productAttributes: [ProductAttributeType!]

  # list of barcodes
  barcodes: [BarcodeType!]
  brand: BrandType
  category: [InventoryCategoryType!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum ProductClassEnum {
  TOP_PRODUCTS
  FEATURED_PRODUCTS
  NEW_ARRIVALS
  BEST_SELLERS
}

enum ProductStructureEnum {
  STOCKABLE
  CONSUMABLE
  SERVICE
}

type InternalProductAttributeInnerType {
  selectedValue: String
  price: String
  productAttribute: ProductAttributeType
}

type InternalProductAttributeType {
  attributes: [InternalProductAttributeInnerType!]
}

type InternalProductAttributesValuesBaseType {
  attributesValues: [AttributeValueBaseRawType!]
}

type InternalProductAttributesValuesType {
  attributesValues: [AttributeValueType!]
}

type InternalProductAttributesValuesFilterType {
  attributesValues: [AttributeValueFilterType!]
}

type InternalProductMaintenanceType {
  active: Boolean
  owner: UserType
  technician: UserType
  prevMaintenanceDuration: Int
  maintenanceDuration: Int
  expectedMeantime: Int
}

type GlobalCategoryProductType {
  googleCategory: GlobalCategoryType
  facebookCategory: GlobalCategoryType
}

type InternalProductType {
  id: ID
  name: String
  description: String
  descriptionList: [String!]
  specs: [ProductSpecsType!]
  externalId: String
  tags: [String!]
  sku: String
  condition: ProductConditionEnum
  status: ProductStatusEnum
  picture: PictureType
  pictures: [PictureType!]
  media: MediaType
  structure: ProductStructureEnum
  rent: Boolean
  variety: ProductVarietyEnum
  price: String
  priceBeforeReduction: String
  discount: DiscountDtoType
  product: ProductType
  target: TargetType!
  catalogueCategory: [CatalogueCategoryType!]
  globalCategory: GlobalCategoryProductType
  tax: String
  seo: CatalogueCategorySeoType
  brand: BrandType
  createdAt: DateTime!
  updatedAt: DateTime!
  class: [ProductClassEnum!]
  barcodes: [BarcodeType!]
}

enum ProductConditionEnum {
  NEW
  REFURBISHED
  USED
}

enum ProductStatusEnum {
  ACTIVE
  ARCHIVED
}

type InternalProductWithStockType {
  id: ID
  name: String
  description: String
  descriptionList: [String!]
  specs: [ProductSpecsType!]
  externalId: String
  tags: [String!]
  sku: String
  condition: ProductConditionEnum
  status: ProductStatusEnum
  picture: PictureType
  pictures: [PictureType!]
  media: MediaType
  structure: ProductStructureEnum
  rent: Boolean
  variety: ProductVarietyEnum
  price: String
  priceBeforeReduction: String
  discount: DiscountDtoType
  product: ProductType
  target: TargetType!
  catalogueCategory: [CatalogueCategoryType!]
  globalCategory: GlobalCategoryProductType
  tax: String
  seo: CatalogueCategorySeoType
  brand: BrandType
  createdAt: DateTime!
  updatedAt: DateTime!
  class: [ProductClassEnum!]
  barcodes: [BarcodeType!]
  stock: StockRawType
}

type InternalProductWithFavoriteStatusType {
  id: ID
  name: String
  description: String
  descriptionList: [String!]
  specs: [ProductSpecsType!]
  externalId: String
  tags: [String!]
  sku: String
  condition: ProductConditionEnum
  status: ProductStatusEnum
  picture: PictureType
  pictures: [PictureType!]
  media: MediaType
  structure: ProductStructureEnum
  rent: Boolean
  variety: ProductVarietyEnum
  price: String
  priceBeforeReduction: String
  discount: DiscountDtoType
  product: ProductType
  target: TargetType!
  catalogueCategory: [CatalogueCategoryType!]
  globalCategory: GlobalCategoryProductType
  tax: String
  seo: CatalogueCategorySeoType
  brand: BrandType
  createdAt: DateTime!
  updatedAt: DateTime!
  class: [ProductClassEnum!]
  barcodes: [BarcodeType!]
  isFavorite: Boolean
}

type InternalProductWithoutClassType {
  id: ID
  name: String
  description: String
  descriptionList: [String!]
  specs: [ProductSpecsType!]
  externalId: String
  tags: [String!]
  sku: String
  condition: ProductConditionEnum
  status: ProductStatusEnum
  picture: PictureType
  pictures: [PictureType!]
  media: MediaType
  structure: ProductStructureEnum
  rent: Boolean
  variety: ProductVarietyEnum
  price: String
  priceBeforeReduction: String
  discount: DiscountDtoType
  product: ProductType
  target: TargetType!
  catalogueCategory: [CatalogueCategoryType!]
  globalCategory: GlobalCategoryProductType
  tax: String
  seo: CatalogueCategorySeoType
  brand: BrandType
  createdAt: DateTime!
  updatedAt: DateTime!
  internalProductAttributes: InternalProductAttributeType
  barcodes: [BarcodeType!]
  ratings: String
}

type InternalProductByClassType {
  BEST_SELLERS: [InternalProductWithoutClassType!]
  NEW_ARRIVALS: [InternalProductWithoutClassType!]
  TOP_PRODUCTS: [InternalProductWithoutClassType!]
  FEATURED_PRODUCTS: [InternalProductWithoutClassType!]
}

type InternalProductWithoutClassWithFavoriteStatusType {
  id: ID
  name: String
  description: String
  descriptionList: [String!]
  specs: [ProductSpecsType!]
  externalId: String
  tags: [String!]
  sku: String
  condition: ProductConditionEnum
  status: ProductStatusEnum
  picture: PictureType
  pictures: [PictureType!]
  media: MediaType
  structure: ProductStructureEnum
  rent: Boolean
  variety: ProductVarietyEnum
  price: String
  priceBeforeReduction: String
  discount: DiscountDtoType
  product: ProductType
  target: TargetType!
  catalogueCategory: [CatalogueCategoryType!]
  globalCategory: GlobalCategoryProductType
  tax: String
  seo: CatalogueCategorySeoType
  brand: BrandType
  createdAt: DateTime!
  updatedAt: DateTime!
  internalProductAttributes: InternalProductAttributeType
  barcodes: [BarcodeType!]
  ratings: String
  isFavorite: Boolean
}

type InternalProductByClassTypeWithFavoriteStatus {
  BEST_SELLERS: [InternalProductWithoutClassWithFavoriteStatusType!]
  NEW_ARRIVALS: [InternalProductWithoutClassWithFavoriteStatusType!]
  TOP_PRODUCTS: [InternalProductWithoutClassWithFavoriteStatusType!]
  FEATURED_PRODUCTS: [InternalProductWithoutClassWithFavoriteStatusType!]
}

type InternalProductWithRatingsType {
  id: ID
  name: String
  description: String
  descriptionList: [String!]
  specs: [ProductSpecsType!]
  externalId: String
  tags: [String!]
  sku: String
  condition: ProductConditionEnum
  status: ProductStatusEnum
  picture: PictureType
  pictures: [PictureType!]
  media: MediaType
  structure: ProductStructureEnum
  rent: Boolean
  variety: ProductVarietyEnum
  price: String
  priceBeforeReduction: String
  discount: DiscountDtoType
  product: ProductType
  catalogueCategory: [CatalogueCategoryType!]
  tax: String
  seo: CatalogueCategorySeoType
  brand: BrandType
  createdAt: DateTime!
  updatedAt: DateTime!
  class: [ProductClassEnum!]
  barcodes: [BarcodeType!]
  target: TargetFilterType!
  ratings: String
}

type InternalProductWithRatingsWithFavoriteStatusType {
  id: ID
  name: String
  description: String
  descriptionList: [String!]
  specs: [ProductSpecsType!]
  externalId: String
  tags: [String!]
  sku: String
  condition: ProductConditionEnum
  status: ProductStatusEnum
  picture: PictureType
  pictures: [PictureType!]
  media: MediaType
  structure: ProductStructureEnum
  rent: Boolean
  variety: ProductVarietyEnum
  price: String
  priceBeforeReduction: String
  discount: DiscountDtoType
  product: ProductType
  catalogueCategory: [CatalogueCategoryType!]
  tax: String
  seo: CatalogueCategorySeoType
  brand: BrandType
  createdAt: DateTime!
  updatedAt: DateTime!
  class: [ProductClassEnum!]
  barcodes: [BarcodeType!]
  target: TargetFilterType!
  ratings: String
  isFavorite: Boolean
}

type InternalProductWithQuantityType {
  id: ID
  name: String
  description: String
  descriptionList: [String!]
  specs: [ProductSpecsType!]
  externalId: String
  tags: [String!]
  sku: String
  condition: ProductConditionEnum
  status: ProductStatusEnum
  picture: PictureType
  pictures: [PictureType!]
  media: MediaType
  structure: ProductStructureEnum
  rent: Boolean
  variety: ProductVarietyEnum
  price: String
  priceBeforeReduction: String
  discount: DiscountDtoType
  product: ProductType
  target: TargetType!
  catalogueCategory: [CatalogueCategoryType!]
  globalCategory: GlobalCategoryProductType
  tax: String
  seo: CatalogueCategorySeoType
  brand: BrandType
  createdAt: DateTime!
  updatedAt: DateTime!
  class: [ProductClassEnum!]
  quantity: Int
}

type BarcodePeriodCreditType {
  periodCycle: RecurrenceType!
  periodValue: Int!
  amount: String
}

enum RecurrenceType {
  HOURLY
  DAILY
  WEEKLY
  MONTHLY
  YEARLY
}

type PixelBarcodeType {
  include: Boolean
}

type BarcodeBaseRawType {
  id: ID!
  barcode: String!
  name: String
  price: String
  priceCredit: [BarcodePeriodCreditType!]
  discount: DiscountDtoType
  condition: ProductConditionEnum
  status: ProductStatusEnum
  media: MediaType
  catalogueCategory: [CatalogueCategoryType!]
  maintenance: InternalProductMaintenanceType
  supplier: CompanyType
  pixel: PixelBarcodeType
  priceList: [ProductPriceListType!]
  taxes: [ProductTaxesType!]
  createdAt: DateTime!
  updatedAt: DateTime!
  productAttributesValues: InternalProductAttributesValuesBaseType
}

type BarcodeType {
  id: ID!
  barcode: String!
  name: String
  price: String
  priceCredit: [BarcodePeriodCreditType!]
  discount: DiscountDtoType
  condition: ProductConditionEnum
  status: ProductStatusEnum
  media: MediaType
  catalogueCategory: [CatalogueCategoryType!]
  maintenance: InternalProductMaintenanceType
  supplier: CompanyType
  pixel: PixelBarcodeType
  priceList: [ProductPriceListType!]
  taxes: [ProductTaxesType!]
  createdAt: DateTime!
  updatedAt: DateTime!
  product: ProductType
  internalProduct: InternalProductType
  productAttributesValues: InternalProductAttributesValuesType
}

type BarcodeWithStockDataType {
  id: ID!
  barcode: String!
  name: String
  price: String
  priceCredit: [BarcodePeriodCreditType!]
  discount: DiscountDtoType
  condition: ProductConditionEnum
  status: ProductStatusEnum
  media: MediaType
  catalogueCategory: [CatalogueCategoryType!]
  maintenance: InternalProductMaintenanceType
  supplier: CompanyType
  pixel: PixelBarcodeType
  priceList: [ProductPriceListType!]
  taxes: [ProductTaxesType!]
  createdAt: DateTime!
  updatedAt: DateTime!
  product: ProductType
  internalProduct: InternalProductType
  productAttributesValues: InternalProductAttributesValuesType
  currentStock: Int
  outOfStock: Boolean
}

type BarcodeWithStockType {
  id: ID!
  barcode: String!
  name: String
  price: String
  priceCredit: [BarcodePeriodCreditType!]
  discount: DiscountDtoType
  condition: ProductConditionEnum
  status: ProductStatusEnum
  media: MediaType
  catalogueCategory: [CatalogueCategoryType!]
  maintenance: InternalProductMaintenanceType
  supplier: CompanyType
  pixel: PixelBarcodeType
  priceList: [ProductPriceListType!]
  taxes: [ProductTaxesType!]
  createdAt: DateTime!
  updatedAt: DateTime!
  product: ProductType
  internalProduct: InternalProductType
  productAttributesValues: InternalProductAttributesValuesType
  stock: StockRawType
}

type BarcodeForTargetType {
  id: ID!
  barcode: String!
  name: String
  price: String
  priceCredit: [BarcodePeriodCreditType!]
  discount: DiscountDtoType
  condition: ProductConditionEnum
  status: ProductStatusEnum
  media: MediaType
  catalogueCategory: [CatalogueCategoryType!]
  maintenance: InternalProductMaintenanceType
  supplier: CompanyType
  pixel: PixelBarcodeType
  priceList: [ProductPriceListType!]
  taxes: [ProductTaxesType!]
  createdAt: DateTime!
  updatedAt: DateTime!
  productAttributesValues: InternalProductAttributesValuesType
}

type BarcodePaginateType {
  count: Int
  isLast: Boolean
  objects: [BarcodeType!]!
}

type BarcodeWithStockPaginatedType {
  count: Int
  isLast: Boolean
  objects: [BarcodeWithStockType!]!
}

type BarcodeWithStockDataPaginatedType {
  count: Int
  isLast: Boolean
  objects: [BarcodeWithStockDataType!]!
}

type KeyValueType {
  key: String
  value: String
}

type InvoicingProductsType {
  id: ID!
  article: BarcodeType
  label: String
  description: String
  price: String
  total: String
  taxes: [ProductTaxesType!]
  quantity: Int
  discount: DiscountDtoType
  rent: RentalRefType
}

type InvoicingProductsBundleType {
  product: InvoicingProductsType
  text: String
  value: String
  rank: String!
  kind: ProductKindEnum!
}

enum ProductKindEnum {
  PRODUCT
  TEXT
  SECTION
  SEPARATOR
  SUBTOTAL
}

type InvoicingAddressType {
  billing: FullAddressType
  shipping: FullAddressType
}

type InvoicingPriceType {
  net: String
  gross: String
}

type TotalPriceType {
  net: String
  gross: String
}

type taxRankType {
  tax: TaxType
  rank: String
}

type RentalInvoicingType {
  id: ID!
  number: String!
  description: String
  status: GenericInvoicingStatusEnum
  address: InvoicingAddressType
  totalTax: String
  totalPrice: InvoicingPriceType
  toPay: String
  logistic: LogisticType
  project: ProjectType
  date: DateTime
}

enum GenericInvoicingStatusEnum {
  DRAFT
  OPEN
  ISSUED
  NEGOCIATION
  CONFIRMED
  DELIVERED
  CANCELED
}

type RentalInvoicingProductsType {
  id: ID!
  article: BarcodeType
  label: String
  description: String
  price: String
  total: String
  quantity: Int
  discount: DiscountDtoType
}

type RentalType {
  id: ID!
  location: String
  description: String
  start: DateTime!
  end: DateTime!
  status: RentalStatusEnum
  note: RentalNoteType
  createdAt: DateTime!
  updatedAt: DateTime!
  product: RentalInvoicingProductsType
  order: RentalInvoicingType
  invoice: RentalInvoicingType
  deliveryNote: RentalInvoicingType
}

type MailResponseDto {
  accepted: [String!]!
  rejected: [String!]!
  envelopeTime: Float!
  messageTime: Float!
  messageSize: Float!
  response: String!
  messageId: String!
}

type EmailTemplateType {
  name: EmailTemplateTypeEnum!
  content: String!
}

enum EmailTemplateTypeEnum {
  STYLE
  WELCOME_USER
  VALIDATE_EMAIL
  FORGOT_PASSWORD
  CONFIRM_PASSWORD
  CONTACT_REQUEST
  DEMO_BOOKING
  EXPORT
  FORM_EXPORT
  INVOICE
  DOCUMENT
  MERGE_ACCOUNTS
  PARTNERSHIP_REFERRAL
  PARTNERSHIP_REQUEST
  POS_CONTACT_REQUEST
  TABLE_GUIDANCE
}

type AuthDashboardAgeType {
  ageRange: String!
  count: Int!
}

type AuthDashboardRoleType {
  role: UserRole!
  count: Int!
}

type AuthDashboardGenderType {
  gender: Gender!
  count: Int!
}

type AuthDashboardUsersByAppsType {
  app: App!
  count: Int!
}

type AuthDashboardMaritalStatusType {
  maritalStatus: MaritalStatus!
  count: Int!
}

type AuthDashboardUsersByRegionType {
  region: CountryEnum!
  count: Int!
}

enum CountryEnum {
  AFGHANISTAN
  ALBANIA
  ALGERIA
  ANDORRA
  ANGOLA
  ANTIGUA_AND_BARBUDA
  ARGENTINA
  ARMENIA
  AUSTRALIA
  AUSTRIA
  AZERBAIJAN
  BAHAMAS
  BAHRAIN
  BANGLADESH
  BARBADOS
  BELARUS
  BELGIUM
  BELIZE
  BENIN
  BHUTAN
  BOLIVIA
  BOSNIA_AND_HERZEGOVINA
  BOTSWANA
  BRAZIL
  BRUNEI
  BULGARIA
  BURKINA_FASO
  BURUNDI
  IVORY_COAST
  CABO_VERDE
  CAMBODIA
  CAMEROON
  CANADA
  CENTRALA_FRICAN_REPUBLIC
  CHAD
  CHILE
  CHINA
  COLOMBIA
  COMOROS
  CONGO_BRAZZAVILLE
  COSTA_RICA
  CROATIA
  CUBA
  CYPRUS
  CZECH_REPUBLIC
  DEMOCRATIC_REPUBLIC_OF_THE_CONGO
  DENMARK
  DJIBOUTI
  DOMINICA
  DOMINICAN_REPUBLIC
  ECUADOR
  EGYPT
  EL_SALVADOR
  EQUATORIAL_GUINEA
  ERITREA
  ESTONIA
  ESWATINI
  ETHIOPIA
  FIJI
  FINLAND
  FRANCE
  GABON
  GAMBIA
  GEORGIA
  GERMANY
  GHANA
  GREECE
  GRENADA
  GUATEMALA
  GUINEA
  GUINEA_BISSAU
  GUYANA
  HAITI
  HOLY_SEE
  HONDURAS
  HUNGARY
  ICELAND
  INDIA
  INDONESIA
  IRAN
  IRAQ
  IRELAND
  ISRAEL
  ITALY
  JAMAICA
  JAPAN
  JORDAN
  KAZAKHSTAN
  KENYA
  KIRIBATI
  KUWAIT
  KYRGYZSTAN
  LAOS
  LATVIA
  LEBANON
  LESOTHO
  LIBERIA
  LIBYA
  LIECHTENSTEIN
  LITHUANIA
  LUXEMBOURG
  MADAGASCAR
  MALAWI
  MALAYSIA
  MALDIVES
  MALI
  MALTA
  MARSHALL_ISLANDS
  MAURITANIA
  MAURITIUS
  MEXICO
  MICRONESIA
  MOLDOVA
  MONACO
  MONGOLIA
  MONTENEGRO
  MOROCCO
  MOZAMBIQUE
  MYANMAR
  NAMIBIA
  NAURU
  NEPAL
  NETHERLANDS
  NEW_ZEALAND
  NICARAGUA
  NIGER
  NIGERIA
  NORTH_KOREA
  NORTH_MACEDONIA
  NORWAY
  OMAN
  PAKISTAN
  PALAU
  PALESTINE_STATE
  PANAMA
  PAPUA_NEW_GUINEA
  PARAGUAY
  PERU
  PHILIPPINES
  POLAND
  PORTUGAL
  QATAR
  ROMANIA
  RUSSIA
  RWANDA
  SAINT_KITTS_AND_NEVIS
  SAINT_LUCIA
  SAINT_VINCENT_AND_THE_GRENADINES
  SAMOA
  SAN_MARINO
  SAO_TOME_AND_PRINCIPE
  SAUDI_ARABIA
  SENEGAL
  SERBIA
  SEYCHELLES
  SIERRA_LEONE
  SINGAPORE
  SLOVAKIA
  SLOVENIA
  SOLOMON_ISLANDS
  SOMALIA
  SOUTH_AFRICA
  SOUTH_KOREA
  SOUTH_SUDAN
  SPAIN
  SRI_LANKA
  SUDAN
  SURINAME
  SWEDEN
  SWITZERLAND
  SYRIA
  TAJIKISTAN
  TANZANIA
  THAILAND
  TIMOR_LESTE
  TOGO
  TONGA
  TRINIDAD_AND_TOBAGO
  TUNISIA
  TURKEY
  TURKMENISTAN
  TUVALU
  UGANDA
  UKRAINE
  UNITED_ARAB_EMIRATES
  UNITED_KINGDOM
  UNITED_STATES_OF_AMERICA
  URUGUAY
  UZBEKISTAN
  VANUATU
  VENEZUELA
  VIETNAM
  YEMEN
  ZAMBIA
  ZIMBABWE
  NOT_SPECIFIED
}

type AuthDashboardMailValidationType {
  isMailValid: Boolean!
  count: Int!
}

type AuthDashboardType {
  gender: [AuthDashboardGenderType!]!
  maritalStatus: [AuthDashboardMaritalStatusType!]!
  usersByRegion: [AuthDashboardUsersByRegionType!]!
  mailValidation: [AuthDashboardMailValidationType!]!
  roles: [AuthDashboardRoleType!]!
  usersByApp: [AuthDashboardUsersByAppsType!]!
  age: [AuthDashboardAgeType!]!
}

type AuthDashboardAgeByAppType {
  ageRange: String!
  count: Int!
  app: App!
}

type AuthDashboardRoleByAppType {
  role: UserRole!
  count: Int!
  app: App!
}

type AuthDashboardGenderByAppType {
  gender: Gender!
  count: Int!
  app: App!
}

type AuthDashboardMaritalStatusByAppType {
  maritalStatus: MaritalStatus!
  count: Int!
  app: App!
}

type AuthDashboardUsersByRegionByAppType {
  region: CountryEnum!
  count: Int!
  app: App!
}

type AuthDashboardMailValidationByAppType {
  isMailValid: Boolean!
  count: Int!
  app: App!
}

type AuthDashboardByAppType {
  gender: [AuthDashboardGenderByAppType!]!
  maritalStatus: [AuthDashboardMaritalStatusByAppType!]!
  usersByRegion: [AuthDashboardUsersByRegionByAppType!]!
  mailValidation: [AuthDashboardMailValidationByAppType!]!
  roles: [AuthDashboardRoleByAppType!]!
  usersByApp: [AuthDashboardUsersByAppsType!]!
  age: [AuthDashboardAgeByAppType!]!
}

type OnlineUsersByDeviceTypeType {
  deviceType: DeviceTypeEnum!
  onlineUsers: Int!
}

enum DeviceTypeEnum {
  TV
  TABLET
  CAMERA
  NO_DATA
  DESKTOP
  CONSOLE
  PHABLET
  WEARABLE
  SMARTPHONE
  PERIPHERAL
  CAR_BROWSER
  FEATURE_PHONE
  SMART_DISPLAY
  SMART_SPEAKER
  PORTABLE_MEDIA_PLAYER
}

type AuthDashboardPreviewByAppType {
  totalUsers: Int!
  onlineUsers: Int!
  onlineUsersByDeviceType: [OnlineUsersByDeviceTypeType!]!
}

type GetCockPitDashboardAnalyticsByAppType {
  totalUsers: Int!
  onlineUsers: Int!
}

type DailyCountType {
  total: Int!
  date: String!
}

type DurationsCountType {
  count: Int
  duration: Float
}

type GetCockPitDashboardUserAnalyticsByAppType {
  currentNewUsersCount: Int!
  previousNewUsersCount: Int!
  currentActiveUsersCount: Int!
  previousActiveUsersCount: Int!
  currentReturningUsersCount: Int!
  previousReturningUsersCount: Int!
  dailyNewUsersCount: [DailyCountType!]
  dailyActiveUsersCount: [DailyCountType!]
  dailyReturningUsersCount: [DailyCountType!]
}

type UserLocationType {
  id: ID!
  user: UserType!
  location: LonLatType!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ClientDataType {
  name: String
  engine: String
  family: String
  version: String
  clientType: String
  engineVersion: String
  type: String
}

type OperatingSystemDataType {
  name: String
  version: String
  brand: String
  model: String
}

type MachineDataType {
  id: String
  deviceType: String
  brand: String
  model: String
}

type IosDataType {
  name: String
  model: String
  systemName: String
  systemVersion: String
  localizedModel: String
  utsnameMachine: String
  utsnameRelease: String
  utsnameSysname: String
  utsnameVersion: String
  utsnameNodename: String
  isPhysicalDevice: String
  identifierForVendor: String
}

type AndroidDataType {
  id: String
  host: String
  tags: String
  deviceType: String
  board: String
  brand: String
  model: String
  device: String
  display: String
  product: String
  hardware: String
  androidId: String
  bootloader: String
  fingerprint: String
  manufacturer: String
  versionBaseOS: String
  versionSdkInt: String
  versionRelease: String
  supportedAbis: [String!]
  versionCodename: String
  systemFeatures: [String!]
  isPhysicalDevice: String
  versionIncremental: String
  versionPreviewSdkInt: String
  versionSecurityPatch: String
  supported32BitAbis: [String!]
  supported64BitAbis: [String!]
}

type DeviceDataType {
  iosData: IosDataType!
  androidData: AndroidDataType!
  os: OperatingSystemDataType!
  client: ClientDataType!
  device: MachineDataType!
}

type LoginType {
  accessToken: String!
  expiresIn: Float!
  user: UserType!
}

type UserAuthenticationType {
  actionType: ActionTypeEnum!
  user: UserType!
}

enum ActionTypeEnum {
  LOGIN
  REGISTER
  APPLE_LOGIN
  GOOGLE_LOGIN
  LOGIN_FOR_APP
  FACEBOOK_LOGIN
  REGISTER_FOR_APP
}

type FormOwnerDtoType {
  pos: PointOfSaleType
  wholesaler: WholesalerType
  manufacturer: ManufacturerType
}

type ActivityTypeType {
  id: ID!
  title: String
  description: String
  icon: String
  media: MediaType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type JockerType {
  id: ID!
  title: String
  description: String
  icon: String
  media: MediaType
  target: TargetType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ChallengeTypeTypeJocker {
  jocker: JockerType
  cost: String
}

type ChallengeTypeType {
  id: ID!
  title: String
  description: String
  rules: String
  icon: String
  media: MediaType
  minStep: Int
  minCheckPoints: Int
  minGiftValue: String
  claimReward: String
  activityTypes: [ActivityTypeType!]
  jockers: [ChallengeTypeTypeJocker!]
  fees: String
  enable: Boolean
  target: TargetType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type AudienceCriteriaType {
  id: ID!
  title: String
  description: String
  icon: String
  media: MediaType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type QuestActionDefinitionDefinitionTextBoxType {
  min: Int
  max: Int
}

type QuestActionDefinitionDefinitionRatingType {
  max: Int
  text: Boolean
}

type QuestActionDefinitionDefinitionCalculatedValuesType {
  minValue: Int
  maxValue: Int
  score: Boolean
}

type QuestActionDefinitionDefinitionCalculatedType {
  output: CalculatedOutputEnum
  show: Boolean
  formula: String
  values: [QuestActionDefinitionDefinitionCalculatedValuesType!]
}

enum CalculatedOutputEnum {
  NUMBER
  TEXT
}

type QuestActionDefinitionDefinitionDateType {
  outdated: Boolean
  interval: Boolean
}

type QuestActionDefinitionDefinitionContactType {
  firstname: Boolean
  lastname: Boolean
  email: Boolean
  phone: Boolean
  description: Boolean
  address: Boolean
  birthday: Boolean
  gender: Boolean
  civility: Boolean
  profession: Boolean
  academicLevel: Boolean
  Language: Boolean
}

type QuestActionDefinitionDefinitionNumberType {
  minValue: Int
  maxValue: Int
  interval: Boolean
}

type QuestActionDefinitionDefinitionApiParamsType {
  name: String
  type: String
}

type QuestActionDefinitionDefinitionApiType {
  link: Int
  method: ApiMethods
  auth: String
  secret: String
  params: [QuestActionDefinitionDefinitionApiParamsType!]
}

enum ApiMethods {
  GET
  POST
}

type QuestActionDefinitionDefinitionMatrixType {
  lines: String
  columns: String
}

type QuestActionDefinitionDefinitionToggleType {
  leftLabel: String
  rightLabel: String
}

type QuestActionDefinitionDefinitionChoicesType {
  maxResponses: Float
  personalised: Boolean
  unique: Boolean
  random: Boolean
  leaderboard: Boolean
  api: Boolean
  image: Boolean
  interaction: Boolean
  suggestions: [QuestionDtoType!]
}

type QuestActionDefinitionDefinitionSmileyType {
  levels: Int
}

type QuestActionDefinitionDefinitionScoreType {
  min: Int
}

type QuestActionDefinitionDefinitionLeadType {
  url: String
  image: String
}

type QuestActionDefinitionDefinitionVerificationItemContentType {
  rank: Int
}

type QuestActionDefinitionDefinitionVerificationItemType {
  verification: QuestActionDefinitionDefinitionVerificationItemContentType
  verified: QuestActionDefinitionDefinitionVerificationItemContentType
}

type QuestActionDefinitionDefinitionVerificationType {
  number: QuestActionDefinitionDefinitionVerificationItemType
  email: QuestActionDefinitionDefinitionVerificationItemType
}

type QuestActionDefinitionDefinitionVideoType {
  minSeconds: Int
}

type QuestActionDefinitionDefinitionSocialMediaType {
  socialMedia: SocialType
  action: SocialActionEnum
  socialContent: SocialContentTypeEnum
  url: String
}

enum SocialActionEnum {
  SHARE
  LIKE
}

enum SocialContentTypeEnum {
  PAGE
  PROFILE
  POST
  VIDEO
  STORY
  REEL
}

type QuestActionDefinitionDefinitionAppDownloadType {
  playstore: String
  appstore: String
  appgallery: String
}

type QuestActionDefinitionDefinitionType {
  textBox: QuestActionDefinitionDefinitionTextBoxType
  rating: QuestActionDefinitionDefinitionRatingType
  calculated: QuestActionDefinitionDefinitionCalculatedType
  date: QuestActionDefinitionDefinitionDateType
  contact: QuestActionDefinitionDefinitionContactType
  number: QuestActionDefinitionDefinitionNumberType
  api: QuestActionDefinitionDefinitionApiType
  matrix: QuestActionDefinitionDefinitionMatrixType
  toggle: QuestActionDefinitionDefinitionToggleType
  choices: QuestActionDefinitionDefinitionChoicesType
  smiley: QuestActionDefinitionDefinitionSmileyType
  score: QuestActionDefinitionDefinitionScoreType
  lead: QuestActionDefinitionDefinitionLeadType
  verification: QuestActionDefinitionDefinitionVerificationType
  video: QuestActionDefinitionDefinitionVideoType
  socialMedia: QuestActionDefinitionDefinitionSocialMediaType
  appDownload: QuestActionDefinitionDefinitionAppDownloadType
}

type QuestActionDefinitionType {
  id: ID!
  activityType: ActivityTypeType
  required: Boolean
  definition: QuestActionDefinitionDefinitionType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type DeliveryZonePathType {
  long: Float!
  lat: Float!
  order: Float!
}

type DeliveryZonesType {
  id: ID!
  target: TargetType!
  radius: Float
  order: Float
  minPrice: String
  extraFees: String
  color: String
  type: ZoneTypesEnum!
  paths: [DeliveryZonePathType!]!
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum ZoneTypesEnum {
  Point
  Polygon
}

type AudienceSegmentFilterValuesType {
  startDate: DateTime
  endDate: DateTime
  minValue: String
  maxValue: String
  value: [String!]
  values: String
  zone: DeliveryZonesType
  joinDate: DateTime
}

type AudienceSegmentFilterFieldType {
  value: DateTime
  action: QuestActionDefinitionType
}

type AudienceSegmentFilterType {
  field: AudienceSegmentFilterFieldType
  operator: OperatorEnum
  values: AudienceSegmentFilterValuesType
}

enum OperatorEnum {
  EQUAL
  DIFFERENT
  GREATER
  BETWEEN
}

type AudienceSegmentType {
  rank: Int
  criteria: AudienceCriteriaType
  filters: [AudienceSegmentFilterType!]
}

type AudienceType {
  id: ID!
  title: String
  description: String
  icon: String
  media: MediaType
  segments: [AudienceSegmentType!]
  target: TargetType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ChallengeTypeWinner {
  rank: Int!
  reward: Float
}

type ChallengeTypeCheckpoint {
  checkpoint: Int
  amount: Float
}

type ChallengeType {
  id: ID!
  title: String
  description: String
  media: MediaType
  challengeType: ChallengeTypeType
  startDate: DateTime
  endDate: DateTime
  status: ChallengeStatusEnum
  winners: [ChallengeTypeWinner!]
  checkpoints: [ChallengeTypeCheckpoint!]
  maxAnswers: Int
  audience: AudienceType
  target: TargetType
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum ChallengeStatusEnum {
  DRAFT
  ONGOING
  FINISHED
}

type ChallengeStepType {
  id: ID!
  title: String
  description: String
  media: MediaType
  startDate: DateTime
  endDate: DateTime
  randomize: Boolean
  challenge: ChallengeType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type QuestionDtoType {
  id: ID!
  mandatory: Boolean
  title: String!
  choices: [String!]!
  order: Int!
  type: QuestionTypeEnum!
  challengeStep: ChallengeStepType
  score: Boolean
  points: Int
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum QuestionTypeEnum {
  SHORT_ANSWER
  PARAGRAPH
  MULTIPLE_CHOICE
  CHECKBOXES
  DROPDOWN
  PICTURE
  DATE
  TIME
}

type FormResponseType {
  id: ID!
  title: String!
  description: String!
  questions: [QuestionDtoType!]!
  owner: FormOwnerDtoType!
  type: FormType!
  status: FormStatus!
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum FormType {
  GUIDED
  AUTONOMOUS
}

enum FormStatus {
  DRAFT
  CHECKED
  ONGOING
  FINISHED
}

type FormPaginateType {
  count: Int
  isLast: Boolean
  objects: [FormResponseType!]!
}

type FormDtoType {
  id: ID!
  title: String!
  description: String!
  owner: FormOwnerDtoType!
  questions: [QuestionDtoType!]!
  type: FormType!
  status: FormStatus!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type AnswerDtoType {
  count: Int!
  answers: [String!]!
}

type GetQuestionResponsesPaginateType {
  count: Int
  isLast: Boolean
  results: [AnswerDtoType!]!
  question: QuestionDtoType
}

type TargetDtoType {
  pos: PointOfSaleType
  user: UserType
}

type ResponseDtoType {
  id: ID!
  target: TargetDtoType!
  executor: UserType!
  question: QuestionDtoType!
  answers: [String!]!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ResponsePaginateType {
  count: Int
  isLast: Boolean
  objects: [ResponseDtoType!]!
}

type SingleAnswerDtoType {
  count: Int!
  answer: String!
}

type SummaryResponseDtoType {
  count: Int!
  question: QuestionDtoType!
  answers: [SingleAnswerDtoType!]!
}

type AccessLoggerClientDataType {
  name: String
  engine: String
  family: String
  version: String
  clientType: String
  engineVersion: String
  type: String
}

type AccessLoggerOperatingSystemDataType {
  name: String
  version: String
  brand: String
  model: String
}

type AccessLoggerMachineDataType {
  id: String
  deviceType: String
  brand: String
  model: String
}

type AccessLoggerIosDataType {
  name: String
  model: String
  systemName: String
  systemVersion: String
  localizedModel: String
  utsnameMachine: String
  utsnameRelease: String
  utsnameSysname: String
  utsnameVersion: String
  utsnameNodename: String
  isPhysicalDevice: String
  identifierForVendor: String
}

type AccessLoggerAndroidDataType {
  id: String
  host: String
  tags: String
  deviceType: String
  board: String
  brand: String
  model: String
  device: String
  display: String
  product: String
  hardware: String
  androidId: String
  bootloader: String
  fingerprint: String
  manufacturer: String
  versionBaseOS: String
  versionSdkInt: String
  versionRelease: String
  supportedAbis: [String!]
  versionCodename: String
  systemFeatures: [String!]
  isPhysicalDevice: String
  versionIncremental: String
  versionPreviewSdkInt: String
  versionSecurityPatch: String
  supported32BitAbis: [String!]
  supported64BitAbis: [String!]
}

type AccessLoggerDeviceDataType {
  iosData: AccessLoggerIosDataType!
  androidData: AccessLoggerAndroidDataType!
  os: AccessLoggerOperatingSystemDataType!
  client: AccessLoggerClientDataType!
  device: AccessLoggerMachineDataType!
}

type AccessLoggerRequestType {
  host: String
  port: String
  token: String
  origin: String
  hostname: String
  pathname: String
  protocol: String
  variables: String
  url: String!
  query: String!
  operationName: String!
}

type ReduciblePriceType {
  beforeReduction: String
  afterReduction: String
}

type PriceCreditType {
  amount: String
  periodValue: Int
  periodCycle: RecurrenceType
}

type PriceFullType {
  net: ReduciblePriceType
  gross: ReduciblePriceType
}

type TaxValueType {
  unit: String
  total: String
}

type ProductPriceType {
  unitNet: String
  unitGross: String
  net: String
  gross: String
}

type OrderShoppingCartProductType {
  name: String
  target: TargetType
  taxValue: TaxValueType!
  price: ProductPriceType!
  deliveryMan: UserType
  quantity: Int!
  pickupTime: DateTime
  barcode: BarcodeType!
  orderProductStatus: OrderStatus!
}

enum OrderStatus {
  OPEN
  CONFIRMED
  ASSIGNED
  READY_FOR_PICKUP
  DELIVERED
  CANCELED
}

type MarketPlaceOrderShoppingCartType {
  target: TargetType
  products: [OrderShoppingCartProductType!]
  taxValue: ReduciblePriceType
  deliveryFees: String
  price: PriceFullType
  discount: DiscountDtoType
}

type MarketPlaceOrderDtoType {
  id: ID!
  number: String!
  user: UserType
  notes: String
  orderType: OrderTypeEnum
  installments: [InstallmentType!]
  deliveryAddress: FullAddressType
  hasInvoice: Boolean
  shoppingCart: MarketPlaceOrderShoppingCartType!
  orderTime: DateTime
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum OrderTypeEnum {
  ORDER_AHEAD
  PICKUP
  DELIVERY
  IN_HOUSE
}

type QuestType {
  id: ID!
  title: String!
  description: String!
  media: MediaType
  category: QuestCategoryEnum!
  status: QuestStatusEnum!
  activityType: ActivityTypeType!
  sponsored: Boolean
  leaderboard: Boolean
  rewards: String
  maxAnswers: Int
  audience: AudienceType
  target: TargetType!
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum QuestCategoryEnum {
  INDUSTRY
  FAMILY
  FITNESS
  GASTRONOMY
}

enum QuestStatusEnum {
  DRAFT
  ONGOING
  FINISHED
}

type QuestActionActionContentType {
  content: String
}

type QuestActionActionPerformedType {
  performed: Boolean
}

type QuestActionActionContactType {
  firstname: String
  lastname: String
  email: String
  phone: String
  description: String
  address: FullAddressType
  birthday: DateTime
  gender: Gender
  civility: MaritalStatus
  profession: String
  academicLevel: AcademicLevel
  Language: [LanguageType!]
}

enum AcademicLevel {
  PRIMARY
  HIGHSCOOL
  UNIVERSITY
}

type QuestActionActionDateType {
  startDate: DateTime
  endDate: DateTime
}

type QuestActionActionNumberType {
  from: Float
  to: Float
}

type QuestActionActionApiType {
  code: Float
  content: Float
}

type QuestActionActionVerificationContentType {
  verification: QuestActionActionPerformedType
  verified: QuestActionActionPerformedType
}

type QuestActionActionVerificationType {
  number: QuestActionActionVerificationContentType
  email: QuestActionActionVerificationContentType
}

type QuestActionActionChoicesType {
  responses: [ResponseDtoType!]
}

type QuestActionActionType {
  textBox: QuestActionActionContentType
  rating: QuestActionActionContentType
  calculated: QuestActionActionContentType
  date: QuestActionActionDateType
  contact: QuestActionActionContactType
  number: QuestActionActionNumberType
  api: QuestActionActionApiType
  matrix: QuestActionActionContentType
  toggle: QuestActionActionContentType
  choices: QuestActionActionChoicesType
  smiley: QuestActionActionContentType
  score: QuestActionActionContentType
  lead: QuestActionActionContentType
  verification: QuestActionActionVerificationType
  video: QuestActionActionPerformedType
  socialMedia: QuestActionActionPerformedType
  appDownload: QuestActionActionPerformedType
}

type QuestActionType {
  id: ID!
  status: QuestActionStatus!
  user: UserType!
  activity: QuestActivityType!
  action: QuestActionActionType!
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum QuestActionStatus {
  EXPIRED
  PERFORMED
  IN_PROGRESS
}

type IQuestActivityActivitiesConditionConditionActionType {
  definition: QuestActivityConditionType
  action: QuestActionActionType
}

enum QuestActivityConditionType {
  ACTION
  SCORE
}

type IQuestActivityActivitiesConditionConditionScoreType {
  operator: OperatorEnum
  value: OperatorEnum
}

type IQuestActivityActivitiesConditionConditionType {
  action: IQuestActivityActivitiesConditionConditionActionType
  score: IQuestActivityActivitiesConditionConditionScoreType
}

type IQuestActivityActivitiesConditionType {
  conditionType: QuestActivityConditionType
  condition: IQuestActivityActivitiesConditionConditionType
  transition: QuestActivityTransitionType
  endMessage: String
}

enum QuestActivityTransitionType {
  CONNECTION
  END
}

type IQuestActivityActivitiesTransitionType {
  title: String
  description: String
}

type IQuestActivityActivitiesType {
  action: QuestActionDefinitionType
  transition: IQuestActivityActivitiesTransitionType
  condition: IQuestActivityActivitiesConditionType
}

type QuestActivityType {
  id: ID!
  title: String
  description: String
  tags: [String!]
  media: MediaType
  quest: QuestType
  rank: Int
  activities: [IQuestActivityActivitiesType!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ActivityLogActionType {
  quest: QuestType
  activity: QuestActivityType
  order: MarketPlaceOrderDtoType
}

type ActivityLogAffectedType {
  user: UserType
  pos: PointOfSaleType
  wholesaler: WholesalerType
  manufacturer: ManufacturerType
}

type ActivityLogBalanceAmountType {
  qualitative: String
  quantitative: String
}

type ActivityLogBalanceType {
  sign: TaxSignEnum!
  amount: ActivityLogBalanceAmountType
}

type ActivityLogType {
  id: ID!
  balance: ActivityLogBalanceType
  action: ActivityLogActionType
  affected: ActivityLogAffectedType
  target: ActivityLogAffectedType
  activityType: ActivityLogTypeEnum
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum ActivityLogTypeEnum {
  CONVERSION
  ORDER_ADDED
  WALLET_TOPUP
  ONSITE_ACTIVITY
  QUEST_FULFILLED
  REPUTATION_LOST
  DEAL_ORDER_ADDED
  QUEST_ACTIVITY_FULFILLED
}

type ActivityLogPaginateType {
  count: Int
  isLast: Boolean
  objects: [ActivityLogType!]!
}

type RequestRequestorType {
  firstName: String
  lastName: String
  email: String
  phone: IPhoneType
  address: FullAddressType
}

type RequestCompanyType {
  name: String
  address: FullAddressType
  vatId: String
  registerNo: String
  licenceNo: String
  website: String
  email: String
  phone: IPhoneType
}

type RequestRequestType {
  subject: String
  content: String
}

type RequestType {
  id: ID!
  requestor: RequestRequestorType
  company: RequestCompanyType
  request: RequestRequestType
  type: RequestTypeEnum
  status: RequestStatusEnum
  target: TargetType
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum RequestTypeEnum {
  CONTACT
  DEMO
  PARTNER
}

enum RequestStatusEnum {
  REQUESTED
  TREATED
  CLOSED
}

type OriginType {
  id: ID!
  url: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PartnerReferralType {
  id: ID!
  posTitle: String
  picture: PictureType
  address: FullAddressType
  referralReference: String
  content: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type CloudinaryResourceType {
  public_id: String
  format: String
  version: String
  resource_type: String
  type: String
  created_at: String
  bytes: String
  width: String
  height: String
  url: String
  secure_url: String
}

type CloudinarySignatureType {
  tags: String
  folder: String
  public_id: String
  timestamp: Float
  signature: String
}

type ShortcutType {
  id: ID!
  label: String!
  description: String
  icon: String!
  picture: PictureType
  link: String!
  router: Boolean!
  user: UserType!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type StaticDataType {
  id: ID
  key: String
  value: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type VersionType {
  id: ID!
  version: String!
  platform: PlatformEnum!
  requireUpdate: Boolean!
  versionContent: [VersionContentType!]!
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum PlatformEnum {
  IOS
  ANDROID
  WEB
  DESKTOP
}

type VersionContentType {
  contentType: VersionContentTypeEnum!
  content: String!
}

enum VersionContentTypeEnum {
  ADDED
  CHANGED
  FIXED
}

type VersionsPaginateType {
  count: Int
  isLast: Boolean
  objects: [VersionType!]!
}

type BookingAttributeType {
  id: ID!
  label: String!
  isRequired: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type SettingsAttributeType {
  value: String!
  attribute: BookingAttributeType!
}

type BookingType {
  id: ID!
  user: UserType!
  pos: PointOfSaleType!
  bookingNumber: Float
  instructions: String
  bookingTime: DateTime
  attributes: [SettingsAttributeType!]
  people: Int
  status: BookingStatusEnum
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum BookingStatusEnum {
  OPEN
  CONFIRMED
  CLOSED
  CANCELED
}

type AdhocNotificationType {
  title: String
  executed: Boolean
  executedAt: DateTime
  description: String
  picture: PictureType
}

type NotificationOnsiteConverterType {
  qualitativeAmountPushed: String
  quantitativeAmountPushed: String
}

type ActionType {
  reputationLoss: Float
  internalProduct: String
  onsite: NotificationOnsiteConverterType
  adhocNotification: AdhocNotificationType
  booking: BookingType
  subscription: String
  order: String
  adhocOrder: String
  table: String
  quest: String
  activity: String
}

type SubjectsType {
  pos: String
  user: String
  consumer: String
  deliveryMan: String
}

type SubjectsFullType {
  pos: PointOfSaleType
  user: UserType
  consumer: UserType
  deliveryMan: UserType
}

type NotificationType {
  id: ID!
  event: EventTypeEnum
  seen: Boolean
  executed: Boolean
  executedAt: DateTime
  createdAt: DateTime!
  updatedAt: DateTime!
  action: ActionType
  subjects: SubjectsType
}

enum EventTypeEnum {
  QUEST_FULFILLED
  QUEST_ACTIVITY_FULFILLED
  REPUTATION_LOST
  APP_LOG
  PUSH_AMOUNT
  ORDER_CREATED
  ADHOC_NOTIFICATION
  SUBSCRIPTION_APPROVED
  SUBSCRIPTION_REJECTED
  SUBSCRIPTION_REQUESTED
  PRODUCT_CANCELLED
  PRODUCT_STATUS_UPDATED
  PRODUCT_PAYMENT_STATUS_UPDATED
  WALLET_TOPUP
  WAITER_CALLED
  CALL_WAITER_FOR_CHECK
  DELIVERY_MAN_ASSIGNED
  DEAL_CONFIRMED
  BOOKING_CREATED
  BOOKING_CONFIRMED
  BOOKING_CANCELLED_BY_POS
  BOOKING_CANCELLED_BY_CONSUMER
}

type AdhocNotificationTestType {
  event: EventTypeEnum
  executed: Boolean
  executedAt: DateTime
  seen: Boolean
  action: ActionType
}

type UnseenNotificationCountType {
  count: Int!
}

type NotificationFullType {
  id: ID!
  event: EventTypeEnum
  seen: Boolean
  executed: Boolean
  executedAt: DateTime
  createdAt: DateTime!
  updatedAt: DateTime!
  action: ActionType
  subjects: SubjectsFullType
}

type NotificationResponse {
  success: Boolean!
}

type GroupInviteType {
  id: ID!
  group: GroupType
  requestor: UserType
  status: GroupInviteStatusEnum
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum GroupInviteStatusEnum {
  PENDING
  CONFIRMED
  CANCELED
  REJECTED
}

type GroupLeaderboardBaseType {
  user: UserType!
  group: GroupType!
  credit: String!
  rank: Int!
  rankDifference: Int!
  effectiveDate: DateTime!
}

type GroupLeaderboardType {
  user: UserType!
  group: GroupType!
  credit: String!
  rank: Int!
  rankDifference: Int!
  effectiveDate: DateTime!
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type FollowType {
  id: ID!
  user: UserType!
  target: TargetWithGroupType!
}

type MembersType {
  users: [UserType!]
}

type LastMessageType {
  text: String
  gif: String
  sticker: String
  media: MessageMediaType
  location: LonLatType
  custom: CustomMessageType
  unread: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

type MessageGroupWallpaperType {
  picture: PictureType
  gradientColors: [String!]
  assetImage: String
}

type MessageGroupType {
  id: ID!
  name: String
  mute: Boolean
  creator: UserType
  profilePicture: PictureType
  wallpaper: MessageGroupWallpaperType
  sound: MessageSoundEnum
  status: MessageGroupStatusEnum
  type: MessageGroupTypeEnum
  members: MembersType
  lastMessage: LastMessageType
  unreadCount: Int
  isDirectMessage: Boolean
  target: TargetType
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum MessageSoundEnum {
  DEFAULT
  NONE
  AURORA
}

enum MessageGroupStatusEnum {
  ACTIVE
  ARCHIVED
}

enum MessageGroupTypeEnum {
  SUPPORT
  INTERNAL
}

type MessageMediaType {
  picture: [PictureType!]
  video: [PictureType!]
}

type CustomMessageType {
  id: String
  type: String
}

type MessageType {
  id: ID!
  text: String
  gif: String
  sticker: String
  custom: CustomMessageType
  media: MessageMediaType
  location: LonLatType
  messageGroup: MessageGroupType!
  sender: UserType!
  seenBy: [UserType!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

type AccountType {
  id: ID!
  expiresAt: DateTime
  user: UserType
  targets: TargetsType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type AccountPaginateType {
  count: Int
  isLast: Boolean
  objects: [AccountType!]!
}

type CompanyPaginateType {
  count: Int
  isLast: Boolean
  objects: [CompanyType!]!
}

type CompanyContactType {
  id: ID!
  firstName: String
  lastName: String
  email: String
  phone: IPhoneType
  dateOfBirth: DateTime
  chatContact: [SocialValueType!]
  socialMedia: [SocialValueType!]
  media: MediaType
  tags: [String!]
  lastContacted: DateTime
  leadScore: String
  externalId: String
  company: CompanyType
  address: FullAddressType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type CompanyContactPaginateType {
  count: Int
  isLast: Boolean
  objects: [CompanyContactType!]!
}

type CompanySettingsPurchaseNoteType {
  reference: DocumentReferenceModelEnum
  prefix: String
  note: String
}

enum DocumentReferenceModelEnum {
  WITH_PREFIX
  WITH_PREFIX_AND_DATE
  WITH_DATE
  WITH_DATE_WITHOUT_HYPHEN
  WITHOUT_PREFIX
}

type CompanySettingsPurchaseType {
  inventory: CompanySettingsPurchaseNoteType
  order: CompanySettingsPurchaseNoteType
  invoice: CompanySettingsPurchaseNoteType
  deliveryNote: CompanySettingsPurchaseNoteType
}

type CompanySettingsSaleQuotationValidityType {
  period: String
  cycle: String
}

type CompanySettingsSaleQuotationType {
  reference: DocumentReferenceModelEnum
  prefix: String
  label: String
  validity: CompanySettingsSaleQuotationValidityType
  color: String
  note: String
}

type CompanySettingsSaleType {
  quotation: CompanySettingsSaleQuotationType
  order: CompanySettingsSaleQuotationType
  invoice: CompanySettingsSaleQuotationType
  deliveryNote: CompanySettingsSaleQuotationType
  issueNote: CompanySettingsSaleQuotationType
}

type CompanySettingsTicketsType {
  prefix: String
}

type CompanySettingsType {
  id: ID!
  sale: CompanySettingsSaleType
  purchase: CompanySettingsPurchaseType
  tickets: CompanySettingsTicketsType
  logistic: CompanySettingsTicketsType
  company: CompanyType
  documentLogo: PictureType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type DepartmentBaseType {
  id: ID!
  name: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type DepartmentType {
  id: ID!
  name: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  target: TargetType!
}

type AssigneeDtoType {
  user: UserType
  pos: PointOfSaleType
  wholesaler: WholesalerType
  manufacturer: ManufacturerType
}

type ModulesDefinitionType {
  id: ID!
  name: String!
  target: TargetTypeEnum
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum TargetTypeEnum {
  POS
  MANUFACTURER
  USER
}

type ModulesAssignmentType {
  id: ID!
  module: ModulesDefinitionType!
  assignee: AssigneeDtoType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type SupplierType {
  id: ID!
  reference: String!
  externalId: String!
  supplier: TargetType!
  target: TargetType!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ComplaintTargetType {
  user: UserType
  pos: PointOfSaleType
  wholesaler: WholesalerType
  manufacturer: ManufacturerType
}

type ComplaintType {
  id: ID!
  reporter: UserType!
  report: String!
  target: ComplaintTargetType!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type BrandPaginateType {
  count: Int
  isLast: Boolean
  objects: [BrandType!]!
}

type ProductFilterType {
  createdAtRange: DateRangeType
  updatedAtRange: DateRangeType
  priceRange: PriceRangeType

  # list of brands
  brands: [BrandType!]

  # list of inventoryCategories
  categories: [InventoryCategoryType!]

  # list of productAttributes
  productAttributes: [ProductAttributeType!]

  # list of barcodes
  barcodes: [BarcodeType!]
  structure: [ProductStructureEnum!]
  variety: [ProductVarietyEnum!]
  rent: Boolean
}

type ProductPaginateType {
  count: Int
  isLast: Boolean
  objects: [ProductType!]!
}

type ProductPaginateWithFilterType {
  count: Int
  isLast: Boolean
  filter: ProductFilterType
  objects: [ProductType!]!
}

type ProductRatingDefinitionType {
  id: ID
  reviewType: String
  active: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ByMarkRatingType {
  mark: Int!
  count: Int!
}

type AverageRatingType {
  byMark: [ByMarkRatingType!]!
  overAllAverage: String!
}

type ProductRatingType {
  id: ID!
  mark: Int!
  comment: String
  user: UserType!
  reviewType: ProductRatingDefinitionType!
  product: ProductType!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ProductRatingPaginateType {
  count: Int
  isLast: Boolean
  objects: [ProductRatingType!]!
}

type ProductRatingWithStatsPaginatedType {
  count: Int
  isLast: Boolean
  objects: [ProductRatingType!]!
  stats: [ByMarkRatingType!]
}

type InventoryCategoryCountType {
  id: String
  name: String
  picture: PictureType
  layer: Int
  rank: Int
  parent: String
  createdAt: DateTime!
  updatedAt: DateTime!
  numberOfProducts: Int
}

type NumberOfInventoryCategoriesType {
  layer: Int!
  numberOfInventoryCategories: Int!
}

type PriceRangeCountType {
  numberOfProducts: Int!
  priceRange: [Float!]
}

type NumberOfProductsInventoryDashboardType {
  total: Int
  byInventoryCategory: [InventoryCategoryCountType!]!
  byPriceRange: [PriceRangeCountType!]!
  byWholesalerPriceRange: [PriceRangeCountType!]!
  byFactoryPriceRange: [PriceRangeCountType!]!
}

type InventoryDashboardType {
  numberOfBrands: Int
  numberOfProducts: NumberOfProductsInventoryDashboardType!
  numberOfInventoryCategories: [NumberOfInventoryCategoriesType!]!
}

type InventoryCategoryPaginateType {
  count: Int
  isLast: Boolean
  objects: [InventoryCategoryType!]!
}

type ProductsByCatalogueCategoryCountType {
  id: ID!
  name: String
  description: String
  externalId: String
  pictures: [PictureType!]
  variety: ProductVarietyEnum
  parent: CatalogueCategoryBaseType
  portal: Boolean
  pickup: Boolean
  booking: Boolean
  delivery: Boolean
  hasChildren: Boolean!
  rank: Int
  layer: Int!
  seo: CatalogueCategorySeoType
  createdAt: DateTime!
  updatedAt: DateTime!
  numberOfProducts: Int!
}

type POSByPOSCategoryCountType {
  id: ID!
  name: String
  mapPicture: String
  picture: PictureType
  createdAt: DateTime!
  updatedAt: DateTime!
  numberOfPos: Int!
}

type AccountsByRoleCountType {
  numberOfAccounts: Int!
  role: UserRole!
}

type RolesCountType {
  numberOfPosRoles: Int!
  numberOfManufacturersRoles: Int!
  numberOfWholesalersRoles: Int!
  countByRoles: [AccountsByRoleCountType!]!
}

type AccountsCountType {
  total: Int!
  totalNumberOfPosAccounts: Int!
  totalNumberOfWholesalerAccounts: Int!
  totalNumberOfManufacturerAccounts: Int!
}

type InternalProductsByCatalogueCategoryCountType {
  id: ID!
  name: String
  description: String
  externalId: String
  pictures: [PictureType!]
  variety: ProductVarietyEnum
  parent: CatalogueCategoryBaseType
  portal: Boolean
  pickup: Boolean
  booking: Boolean
  delivery: Boolean
  hasChildren: Boolean!
  rank: Int
  layer: Int!
  seo: CatalogueCategorySeoType
  createdAt: DateTime!
  updatedAt: DateTime!
  numberOfProducts: Int!
}

type InternalProductsByInventoryCategoryCountType {
  id: ID!
  name: String!
  picture: PictureType
  layer: Int!
  rank: Int!
  hasChildren: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
  numberOfProducts: Int!
}

type InternalProductsByPOSCountType {
  id: ID!
  name: String
  title: String
  subtitle: String
  description: String
  tags: [String!]
  brandColor: String
  reference: String
  published: Boolean
  picture: PictureType
  outsidePictures: [PictureType!]
  insidePictures: [PictureType!]
  openingHours: OpeningHoursType
  specialOffers: [SpecialOfferType!]
  email: [String!]
  contactEmails: [String!]
  currency: Currency
  languages: [LanguageType!]
  phone: [String!]
  website: String
  chatContact: [SocialValueType!]
  socialMedia: [SocialValueType!]
  averageCustomers: Float
  turnover: String
  locations: [FullAddressType!]
  isFollowed: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
  numberOfPosProducts: Int!
}

type InternalProductsByWholesalerCountType {
  id: ID!
  name: String
  description: String
  address: FullAddressType
  picture: PictureType
  email: String
  website: String
  phone: IPhoneType
  contactEmails: [String!]
  fax: IPhoneType
  createdAt: DateTime!
  updatedAt: DateTime!
  numberOfWholesalerProducts: Int!
}

type InternalProductsByManufacturerCountType {
  id: ID!
  name: String
  description: String
  picture: PictureType
  externalId: String
  address: FullAddressType
  email: String
  website: String
  contactEmails: [String!]
  createdAt: DateTime!
  updatedAt: DateTime!
  numberOfManufacturerProducts: Int!
}

type NumberOfInternalProductsType {
  total: Int!
  byPos: [InternalProductsByPOSCountType!]!
  byWholesalers: [InternalProductsByWholesalerCountType!]!
  byManufacturers: [InternalProductsByManufacturerCountType!]!
  byCatalogueCategory: [InternalProductsByCatalogueCategoryCountType!]!
  byInventoryCategory: [InternalProductsByInventoryCategoryCountType!]!
}

type NumberOfProductsType {
  total: Int!
  byCatalogueCategory: [ProductsByCatalogueCategoryCountType!]!
  byInventoryCategory: [InventoryCategoryCountType!]!
}

type NumberOfPointOfSalesType {
  total: Int!
  byPosCategory: [POSByPOSCategoryCountType!]!
}

type CorporateUserDashboardType {
  gender: [AuthDashboardGenderType!]!
  mailValidation: [AuthDashboardMailValidationType!]!
  age: [AuthDashboardAgeType!]!
  returningUsers: Int!
  newUsers: Int!
}

type CorporateTargetDashboardType {
  numberOfRoles: [AccountsByRoleCountType!]!
  numberOfInternalProducts: NumberOfProductsType!
}

type CorporateUsersStatsType {
  current: Int!
  previous: Int!
  percentage: Float!
}

type GetCorporateUserAnalyticsType {
  activeUsers: CorporateUsersStatsType!
  overAllUsers: CorporateUsersStatsType!
  returningUsers: CorporateUsersStatsType!
}

type PeriodStatsType {
  date: String!
  total: Float!
}

type GetCorporateUserByDayInPeriodAnalyticsType {
  newUsers: [PeriodStatsType!]!
  activeUsers: [PeriodStatsType!]!
}

type TotalAndInPeriodCountsType {
  inPeriod: Int!
  total: Int!
}

type StockStatsType {
  total: Int!
  daily: [PeriodStatsType!]!
}

type StocksCountType {
  inPeriod: Int!
  total: Int!
  inStock: StockStatsType!
  outOfStock: StockStatsType!
}

type RatingsCountType {
  inPeriod: Int!
  total: Int!
  oneStarDaily: [PeriodStatsType!]!
  twoStarsDaily: [PeriodStatsType!]!
  threeStarsDaily: [PeriodStatsType!]!
  fourStarsDaily: [PeriodStatsType!]!
  fiveStarsDaily: [PeriodStatsType!]!
}

type VisitsFieldType {
  current: Int!
  previous: Int!
  percentage: Float!
  weeklyVisits: [PeriodStatsType!]!
}

type ConversionsFieldType {
  current: Int!
  previous: Int!
  percentage: Float!
  weeklyConversions: [PeriodStatsType!]!
}

type ImpressionsFieldType {
  current: Int!
  previous: Int!
  percentage: Float!
  weeklyImpressions: [PeriodStatsType!]!
}

type GetCorporateUsersRequestsAnalyticsType {
  visits: VisitsFieldType!
  impressions: ImpressionsFieldType!
  conversions: ConversionsFieldType!
}

type GetCorporateUsersTechnologiesDashboardDataType {
  web: Int!
  mobile: Int!
  unknown: Int!
  webDaily: [PeriodStatsType!]!
  mobileDaily: [PeriodStatsType!]!
  unknownDaily: [PeriodStatsType!]!
}

type CorporateDashboardType {
  totalNumberOfCompanies: Int!
  totalNumberOfWholesalers: Int!
  totalNumberOfManufacturers: Int!
  numberOfPointOfSales: NumberOfPointOfSalesType!
  rolesCount: RolesCountType!
  accountsCount: AccountsCountType!
  numberOfInternalProducts: NumberOfInternalProductsType!
}

type GetCorporateWarehouseDashboardDataType {
  stocksCount: StocksCountType!
  ratingsCount: RatingsCountType!
  categoriesCount: TotalAndInPeriodCountsType!
  productsCount: TotalAndInPeriodCountsType!
}

type WholesalerPaginateType {
  count: Int
  isLast: Boolean
  objects: [WholesalerType!]!
}

type BrandValidationType {
  headersValid: Boolean!
  isIdComplete: Boolean!
  isNameComplete: Boolean!
  overallValidation: Boolean!
  length: Int!
}

type BarcodeValidationType {
  headersValid: Boolean
  isIdComplete: Boolean
  isNameComplete: Boolean
  isProductsComplete: Boolean
  isPricesComplete: Boolean
  overallValidation: Boolean
  length: Int
  numBarcodesWithAttributes: Int
}

type ProductValidationType {
  headersValid: Boolean
  isIdComplete: Boolean
  isNameComplete: Boolean
  isCategoriesComplete: Boolean
  isBrandsComplete: Boolean
  isVATComplete: Boolean
  overallValidation: Boolean
  length: Int
}

type AttributesValidationType {
  headersValid: Boolean
  isIdComplete: Boolean
  isLabelComplete: Boolean
  isRequiredComplete: Boolean
  isMultipleComplete: Boolean
  overallValidation: Boolean
  length: Int
}

type CategoriesValidationType {
  headersValid: Boolean
  isIdComplete: Boolean
  isLayerComplete: Boolean
  isRankComplete: Boolean
  isNameComplete: Boolean
  isParentComplete: Boolean
  overallValidation: Boolean
  length: Int
}

type AttributesValuesValidationType {
  headersValid: Boolean
  isIdComplete: Boolean
  isValueComplete: Boolean
  isAttributeComplete: Boolean
  overallValidation: Boolean
  length: Int
}

type StockValidationType {
  headersValid: Boolean
  isBarcodeComplete: Boolean
  isMinimumComplete: Boolean
  isCapacityComplete: Boolean
  isStockComplete: Boolean
  overallValidation: Boolean
  length: Int
}

type CatalogueImportValidationType {
  brandValidation: BrandValidationType!
  barcodeValidation: BarcodeValidationType!
  productValidation: ProductValidationType!
  attributesValidation: AttributesValidationType!
  categoriesValidation: CategoriesValidationType!
  attributesValuesValidation: AttributesValuesValidationType!
  stockValidation: StockValidationType!
  notRecognizedSheets: [String!]!
  overallValidation: Boolean!
}

type ManufacturerPaginateType {
  count: Int
  isLast: Boolean
  objects: [ManufacturerType!]!
}

type IsUserNearPOSDtoType {
  isUserNearPOS: Boolean!
}

type PointOfSalePaginateType {
  count: Int
  isLast: Boolean
  objects: [PointOfSaleType!]!
}

type MonthDaysType {
  month: Int!
  days: [Int!]
}

type TimeFromToType {
  from: String
  to: String
}

type BookingTypeType {
  id: ID
  index: Int
  name: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type BookingsStatusesCountType {
  OPEN: Int!
  CLOSED: Int!
  CANCELED: Int!
  CONFIRMED: Int!
}

type BookingsSourcesCountType {
  APP: Int!
  EMAIL: Int!
  PHONE: Int!
  FACEBOOK: Int!
  INSTAGRAM: Int!
}

type BookingsCountType {
  total: Int!
  numberOfPeople: [NumberOfPeopleCountType!]!
  bookingStatuses: BookingsStatusesCountType!
  bookingSources: BookingsSourcesCountType!
}

type NumberOfPeopleCountType {
  numberOfBookings: Int!
  numberOfPeopleRange: [Int!]!
}

type POSCategoryPaginateType {
  count: Int
  isLast: Boolean
  objects: [POSCategoryType!]!
}

type POSServicesPaginateType {
  count: Int
  isLast: Boolean
  objects: [POSServicesType!]!
}

type POSComissionType {
  id: ID!
  pos: PointOfSaleType
  walletComission: String
  marketplaceComission: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type POSContactRequestType {
  id: ID!
  pos: PointOfSaleType
  firstName: String!
  lastName: String!
  email: String!
  phoneNumber: String
  companyName: String
  subject: String!
  content: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type CorporateUserType {
  id: ID!
  email: String
  picture: PictureType
  pictures: [PictureType!]
  covers: [PictureType!]
  roles: [UserRole!]
  username: String
  firstName: String
  status: UserStatus
  title: String
  about: String
  lastName: String
  apps: [App!]
  maritalStatus: MaritalStatus
  gender: Gender
  languages: [LanguageType!]
  isMailValid: Boolean
  plugged: Boolean
  hasAutoGeneratedEmail: Boolean
  dateOfBirth: DateTime
  phoneNumber: String
  phone: PhoneType
  chatContact: [SocialValueType!]
  socialMedia: [SocialValueType!]
  socialLoginData: SocialLoginDataType
  nationality: CountryType
  locale: String
  placeOfBirth: String
  residentialAddress: [FullAddressType!]
  shippingAddress: [FullAddressType!]
  billingAddress: [FullAddressType!]
  mobileTheme: MobileThemesEnum
  source: SourcesEnum
  newsletterSubs: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
  target: TargetType
}

type LoyaltyProgramPaginateType {
  count: Int
  isLast: Boolean
  objects: [LoyaltyProgramType!]!
}

type CorporateRatingDefinitionType {
  id: ID
  reviewType: String
}

type CorporateRatingType {
  id: ID!
  mark: Int!
  comment: String
  product: InternalProductType
  user: UserType!
  reviewType: CorporateRatingDefinitionType!
  target: TargetType!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type CorporateRatingAssignmentType {
  id: ID
  active: Boolean
  target: TargetType
  reviewDefinition: CorporateRatingDefinitionType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PromotionProductsType {
  barcode: BarcodeType!
  discount: DiscountDtoType!
}

type PromotionProductsWithInternalProductType {
  barcode: BarcodeBaseRawType!
  discount: DiscountDtoType!
  internalProduct: InternalProductType!
}

type PromotionType {
  id: ID!
  startDate: DateTime!
  endDate: DateTime!
  status: PromotionStatusEnum!
  target: TargetType!
  createdAt: DateTime!
  updatedAt: DateTime!
  promotion: [PromotionProductsType!]!
}

enum PromotionStatusEnum {
  DRAFT
  ONGOING
  EXPIRED
}

type PromotionWithInternalProductType {
  id: ID!
  startDate: DateTime!
  endDate: DateTime!
  status: PromotionStatusEnum!
  target: TargetType!
  createdAt: DateTime!
  updatedAt: DateTime!
  promotion: [PromotionProductsWithInternalProductType!]!
}

type BarcodeFilterResponseType {
  createdAtRange: DateRangeType
  priceRange: PriceRangeType

  # list of catalogueCategories
  catalogueCategories: [FilterNameFieldType!]
}

type InternalProductFilterType {
  createdAtRange: DateRangeType
  updatedAtRange: DateRangeType
  priceRange: PriceRangeType

  # list of brands
  brands: [FilterNameFieldType!]

  # list of catalogueCategories
  catalogueCategories: [FilterNameFieldType!]

  # list of AttributeValues
  productAttributesValues: [AttributeWithValueFilterType!]
  targets: TargetsType
}

type InternalProductPaginateType {
  count: Int
  isLast: Boolean
  objects: [InternalProductType!]!
}

type InternalProductWithFavoriteStatusPaginateType {
  count: Int
  isLast: Boolean
  objects: [InternalProductWithFavoriteStatusType!]!
}

type BarcodesPaginatedWithFilterType {
  count: Int
  isLast: Boolean
  filter: BarcodeFilterResponseType
  objects: [BarcodeType!]!
}

type InternalProductPaginateWithFilterType {
  count: Int
  isLast: Boolean
  filter: InternalProductFilterType
  objects: [InternalProductType!]!
}

type InternalProductWithRatingsPaginateWithFilterType {
  count: Int
  isLast: Boolean
  filter: InternalProductFilterType
  objects: [InternalProductWithRatingsType!]!
}

type InternalProductWithRatingsPaginateWithFavoriteStatusWithFilterType {
  count: Int
  isLast: Boolean
  filter: InternalProductFilterType
  objects: [InternalProductWithRatingsWithFavoriteStatusType!]!
}

type RecentlyViewedType {
  id: ID!
  user: UserType!
  product: InternalProductType!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type CompareProductType {
  id: ID!
  user: UserType!
  products: InternalProductType!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type FeaturedCorporateType {
  id: ID!
  rank: Int!
  pos: PointOfSaleType
  wholesaler: WholesalerType
  manufacturer: ManufacturerType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type CatalogueCategoryPaginateType {
  count: Int
  isLast: Boolean
  objects: [CatalogueCategoryType!]!
}

type CorporateUserCardType {
  id: ID!
  user: UserType!
  target: TargetType!
  identifier: String!
  cardType: CardTypeEnum!
  validUntil: DateTime!
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum CardTypeEnum {
  PHYSICAL
  VIRTUAL
}

type GenerateUserCardType {
  virtualCard: CorporateUserCardType
  physicalCard: CorporateUserCardType
}

type CorporateUserCardFullPaginatedType {
  count: Int
  isLast: Boolean
  objects: [CorporateUserCardType!]!
}

type MarketPlaceProductType {
  id: ID!
  product: ProductType!
  internalProducts: [InternalProductType!]!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type MarketPlaceProductFilterType {
  createdAtRange: DateRangeType
  updatedAtRange: DateRangeType
  priceRange: PriceRangeType

  # list of brands
  brands: [BrandType!]

  # list of inventoryCategories
  categories: [InventoryCategoryType!]
  targets: TargetsType
}

type AdhocCorporateNotificationType {
  title: String
  executed: Boolean
  executedAt: DateTime
  description: String
  picture: PictureType
}

type CorporateNotificationOnsiteConverterType {
  qualitativeAmountPushed: String
  quantitativeAmountPushed: String
}

type CorporateActionType {
  reputationLoss: Float
  internalProduct: String
  onsite: CorporateNotificationOnsiteConverterType
  adhocNotification: AdhocCorporateNotificationType
  booking: BookingType
  subscription: String
  order: String
  adhocOrder: String
  table: String
  quest: String
  activity: String
}

type CorporateNotificationType {
  id: ID!
  event: EventTypeEnum
  seen: Boolean
  executed: Boolean
  executedAt: DateTime
  user: UserType!
  target: TargetType!
  createdAt: DateTime!
  updatedAt: DateTime!
  action: CorporateActionType
}

type SEOType {
  id: ID!
  target: TargetType!
  googleAnalyticsId: String
  titleTag: String
  metaDescriptionTag: String
  headerTags: [TagType!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

type SeoComponentType {
  metaTitle: String
  metaDesription: String
  metaKeywords: [TagType!]
}

type BlogType {
  id: ID!
  target: TargetType!
  author: UserType!
  status: String!
  title: String!
  url: String
  tags: [String!]
  seo: SeoComponentType
  pictures: [PictureType!]
  sectionData: [BlogDataType!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

type BlogDataType {
  sectionReference: String
  sectionTitle: String
  sectionContent: String
  sectionPictures: [PictureType!]
}

type LandingPagesType {
  id: ID!
  target: TargetType!
  pageType: LandingPageTypeEnum!
  pageReference: String!
  pageTitle: String!
  status: String!
  pageDescription: String
  url: String
  tags: [String!]
  seo: SeoComponentType
  sectionData: [LandingPagesDataType!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum LandingPageTypeEnum {
  ABOUT
  CONTACT
  PRIVACY
  TERMS
  RETURN_EXCHANGE
  SHIPPING
  COPYRIGHT
  FAQ
  PROJECT
  CAREER
  PROJECTS
  BLOG
}

type LandingPagesDataType {
  sectionReference: String
  sectionTitle: String
  sectionContent: String
  sectionPictures: [PictureType!]
}

type SlidesType {
  id: ID!
  target: TargetType!
  reference: String
  visualType: SlideVisualTypeEnum
  content: [SlidesContentType!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum SlideVisualTypeEnum {
  PICTURE
  ICON
}

type SlidesContentType {
  image: PictureType
  icon: String
  title: String
  description: String
  calltoaction: String
}

type VisualsFaviconType {
  size16: PictureType
  size32: PictureType
  size57: PictureType
  size60: PictureType
  size72: PictureType
  size76: PictureType
  size96: PictureType
  size114: PictureType
  size120: PictureType
  size144: PictureType
  size152: PictureType
  size180: PictureType
  size192: PictureType
}

type VisualsType {
  id: ID!
  target: TargetType!
  pageTitle: String
  logo: PictureType
  wide: PictureType
  square: PictureType
  favicon: VisualsFaviconType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type JobDescriptionType {
  description: String
  descriptionList: [String!]
}

type JobSpecsType {
  key: JobDefinitionSpecEnum
  value: String
}

enum JobDefinitionSpecEnum {
  SALARY
  PERKS
  HOLIDAYS
  SKILLS
  LOCATION
  HOMEOFFICE
}

type JobDefinitionBaseType {
  id: ID!
  title: String!
  status: JobDefinitionStatusEnum!
  department: DepartmentBaseType!
  specs: [JobSpecsType!]
  description: JobDescriptionType
  responsibility: JobDescriptionType
  offer: JobDescriptionType
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum JobDefinitionStatusEnum {
  DRAFT
  ONGOING
  HIRED
  CANCELED
}

type JobDefinitionType {
  id: ID!
  title: String!
  status: JobDefinitionStatusEnum!
  specs: [JobSpecsType!]
  description: JobDescriptionType
  responsibility: JobDescriptionType
  offer: JobDescriptionType
  createdAt: DateTime!
  updatedAt: DateTime!
  target: TargetType!
  department: DepartmentType!
}

type JobApplicationBaseType {
  id: ID!
  firstName: String!
  lastName: String!
  email: String!
  message: String!
  cv: DocumentType
  cover: DocumentType
  status: JobApplicationStatusEnum!
  jobDefinition: JobDefinitionBaseType!
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum JobApplicationStatusEnum {
  NEW
  NOT_CONSIDERED
  SHORTLISTED
  HIRED
}

type JobApplicationType {
  id: ID!
  firstName: String!
  lastName: String!
  email: String!
  message: String!
  cv: DocumentType
  cover: DocumentType
  status: JobApplicationStatusEnum!
  createdAt: DateTime!
  updatedAt: DateTime!
  jobDefinition: JobDefinitionType!
}

type OrderShoppingCartAttributeType {
  label: String!
  externalId: String!
  isRequired: Boolean!
  isMultipleChoice: Boolean!
}

type OrderShoppingCartAttributesValuesType {
  label: String!
  externalId: String!
  attribute: OrderShoppingCartAttributeType!
}

type CouponType {
  id: ID!
  couponCode: String!
  target: TargetType!
  user: UserType
  redeemed: Boolean!
  discount: DiscountDtoType!
  from: DateTime
  to: DateTime
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PurchaseType {
  id: ID!
  reference: String!
  externalId: String!
  notes: String
  status: PurchaseStatusEnum!
  installments: [InstallmentType!]!
  user: UserType!
  supplier: SupplierType!
  attachments: [DocumentType!]
  target: TargetType!
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum PurchaseStatusEnum {
  OPEN
  CANCELED
  CONFIRMED
  DELIVERED
}

type CartProductType {
  barcode: BarcodeType
  quantity: Int!
  rent: RentalRefType
  taxValue: TaxValueType!
  price: ProductPriceType!
  priceCredit: PriceCreditType
}

type CartProductForTargetType {
  barcode: BarcodeForTargetType
  quantity: Int!
  taxValue: TaxValueType!
  price: ProductPriceType!
  priceCredit: PriceCreditType
}

type ShoppingCartsType {
  id: ID!
  user: UserType
  taxValue: ReduciblePriceType
  price: PriceFullType
  discount: DiscountDtoType
  target: TargetType
  createdAt: DateTime!
  updatedAt: DateTime!
  products: [CartProductForTargetType!]
}

type ShoppingCartsForTargetType {
  id: ID!
  user: UserType
  taxValue: ReduciblePriceType
  price: PriceFullType
  discount: DiscountDtoType
  target: TargetType
  createdAt: DateTime!
  updatedAt: DateTime!
  products: [CartProductForTargetType!]
}

type InvoiceType {
  id: ID
  number: String
  order: MarketPlaceOrderDtoType!
  month: Int
  year: Int
  sequence: Int
  status: InvoiceStatus
  target: TargetType
  description: String
  dueDate: DateTime
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum InvoiceStatus {
  DRAFT
  ISSUED
  CANCELED
}

type MarketplaceOrdersTypesCountType {
  PICKUP: Int!
  DELIVERY: Int!
  IN_HOUSE: Int!
  ORDER_AHEAD: Int!
}

type MarketplacePaymentMethodsCountType {
  CASH: Int!
  APP_COINS: Int!
}

type MarketplaceOrderByProductsMarketplaceOrderByStatusCountType {
  OPEN: Int!
  CANCELED: Int!
  CONFIRMED: Int!
  DELIVERED: Int!
}

type MarketplaceOrderByProductsMarketplaceOrderByPaymentStatusCountType {
  OPEN: Int!
  PAID: Int!
  CANCELED: Int!
}

type MarketPlaceOrdersCountType {
  total: Int!
  totalProducts: Int!
  orderTypes: MarketplaceOrdersTypesCountType!
  paymentMethods: MarketplacePaymentMethodsCountType!
  productsMarketplaceOrderByStatus: MarketplaceOrderByProductsMarketplaceOrderByStatusCountType!
  productsMarketplaceOrderByPaymentStatus: MarketplaceOrderByProductsMarketplaceOrderByPaymentStatusCountType!
}

type DateStatsType {
  current: String!
  previous: String!
  percentage: String!
}

type PurchasesStatusesFinanceDashboardDataType {
  OPEN: String
  ASSIGNED: String
  CANCELED: String
  CONFIRMED: String
  DELIVERED: String
  READY_FOR_PICKUP: String
}

type PaymentMethodsFinanceDashboardDataType {
  CASH: Int
  CHECK: Int
  APP_COINS: Int
  CREDIT_CARD: Int
  BANK_TRANSFER: Int
  MOBILE_PAYMENT: Int
  AUTOMATIC_DEBIT: Int
  BILL_OF_EXCHANGE: Int
}

type PaymentMethodsStatsType {
  current: PaymentMethodsFinanceDashboardDataType!
  previous: PaymentMethodsFinanceDashboardDataType!
  percentage: PaymentMethodsFinanceDashboardDataType!
}

type NewsletterType {
  id: ID!
  target: TargetType!
  email: String!
  user: UserType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type SaleCustomerType {
  customer: CompanyType
  details: [KeyValueType!]
}

type SaleDeliveryNoteOriginType {
  quotation: QuotationType
  order: SaleOrderType
}

type SaleDeliveryNoteType {
  id: ID!
  number: String!
  creator: UserType
  note: String
  description: String
  status: GenericInvoicingStatusEnum
  details: [KeyValueType!]
  products: [InvoicingProductsBundleType!]
  address: InvoicingAddressType
  totalTax: String
  totalPrice: InvoicingPriceType
  taxes: [taxRankType!]
  toPay: String
  installments: [InstallmentType!]
  logistic: LogisticType
  project: ProjectType
  date: DateTime
  target: TargetType!
  bank: BankDetailsType
  createdAt: DateTime!
  updatedAt: DateTime!
  customer: SaleCustomerType
  origin: SaleDeliveryNoteOriginType
  warehouse: WarehouseType
}

type QuotationConversionType {
  order: SaleOrderType
  deliveryNote: SaleDeliveryNoteType
  invoice: SaleInvoiceType
}

type QuotationType {
  id: ID!
  number: String!
  creator: UserType
  note: String
  description: String
  status: GenericInvoicingStatusEnum
  details: [KeyValueType!]
  products: [InvoicingProductsBundleType!]
  address: InvoicingAddressType
  totalTax: String
  totalPrice: InvoicingPriceType
  taxes: [taxRankType!]
  toPay: String
  installments: [InstallmentType!]
  logistic: LogisticType
  project: ProjectType
  date: DateTime
  target: TargetType!
  bank: BankDetailsType
  createdAt: DateTime!
  updatedAt: DateTime!
  customer: SaleCustomerType
  conversion: QuotationConversionType
}

type SaleInvoiceOriginType {
  quotation: QuotationType
  order: SaleOrderType
}

type SaleInvoiceType {
  id: ID!
  number: String!
  creator: UserType
  note: String
  description: String
  status: GenericInvoicingStatusEnum
  details: [KeyValueType!]
  products: [InvoicingProductsBundleType!]
  address: InvoicingAddressType
  totalTax: String
  totalPrice: InvoicingPriceType
  taxes: [taxRankType!]
  toPay: String
  installments: [InstallmentType!]
  logistic: LogisticType
  project: ProjectType
  date: DateTime
  target: TargetType!
  bank: BankDetailsType
  createdAt: DateTime!
  updatedAt: DateTime!
  customer: SaleCustomerType
  origin: SaleInvoiceOriginType
}

type SaleOrderConversionType {
  deliveryNote: SaleDeliveryNoteType
  invoice: SaleInvoiceType
}

type SaleOrderOriginType {
  quotation: QuotationType
}

type SaleOrderType {
  id: ID!
  number: String!
  creator: UserType
  note: String
  description: String
  status: GenericInvoicingStatusEnum
  details: [KeyValueType!]
  products: [InvoicingProductsBundleType!]
  address: InvoicingAddressType
  totalTax: String
  totalPrice: InvoicingPriceType
  taxes: [taxRankType!]
  toPay: String
  installments: [InstallmentType!]
  logistic: LogisticType
  project: ProjectType
  date: DateTime
  target: TargetType!
  bank: BankDetailsType
  createdAt: DateTime!
  updatedAt: DateTime!
  customer: SaleCustomerType
  conversion: SaleOrderConversionType
  origin: SaleOrderOriginType
}

type SaleIssueNoteType {
  id: ID!
  number: String!
  creator: UserType
  note: String
  description: String
  status: GenericInvoicingStatusEnum
  details: [KeyValueType!]
  products: [InvoicingProductsBundleType!]
  address: InvoicingAddressType
  totalTax: String
  totalPrice: InvoicingPriceType
  taxes: [taxRankType!]
  toPay: String
  installments: [InstallmentType!]
  logistic: LogisticType
  project: ProjectType
  date: DateTime
  target: TargetType!
  bank: BankDetailsType
  createdAt: DateTime!
  updatedAt: DateTime!
  customer: SaleCustomerType
}

type PurchaseSupplierType {
  supplier: CompanyType
  details: [KeyValueType!]
}

type PurchaseDeliveryNoteOriginType {
  order: PurchaseOrderType
}

type PurchaseDeliveryNoteType {
  id: ID!
  number: String!
  creator: UserType
  note: String
  description: String
  status: GenericInvoicingStatusEnum
  details: [KeyValueType!]
  products: [InvoicingProductsBundleType!]
  address: InvoicingAddressType
  totalTax: String
  totalPrice: InvoicingPriceType
  taxes: [taxRankType!]
  toPay: String
  installments: [InstallmentType!]
  logistic: LogisticType
  project: ProjectType
  date: DateTime
  target: TargetType!
  bank: BankDetailsType
  createdAt: DateTime!
  updatedAt: DateTime!
  supplier: PurchaseSupplierType
  origin: PurchaseDeliveryNoteOriginType
  warehouse: WarehouseType
}

type PurchaseInvoiceOriginType {
  order: PurchaseOrderType
}

type PurchaseInvoiceType {
  id: ID!
  number: String!
  creator: UserType
  note: String
  description: String
  status: GenericInvoicingStatusEnum
  details: [KeyValueType!]
  products: [InvoicingProductsBundleType!]
  address: InvoicingAddressType
  totalTax: String
  totalPrice: InvoicingPriceType
  taxes: [taxRankType!]
  toPay: String
  installments: [InstallmentType!]
  logistic: LogisticType
  project: ProjectType
  date: DateTime
  target: TargetType!
  bank: BankDetailsType
  createdAt: DateTime!
  updatedAt: DateTime!
  supplier: PurchaseSupplierType
  origin: PurchaseInvoiceOriginType
}

type PurchaseOrderConversionType {
  deliveryNote: PurchaseDeliveryNoteType
  invoice: PurchaseInvoiceType
}

type PurchaseOrderType {
  id: ID!
  number: String!
  creator: UserType
  note: String
  description: String
  status: GenericInvoicingStatusEnum
  details: [KeyValueType!]
  products: [InvoicingProductsBundleType!]
  address: InvoicingAddressType
  totalTax: String
  totalPrice: InvoicingPriceType
  taxes: [taxRankType!]
  toPay: String
  installments: [InstallmentType!]
  logistic: LogisticType
  project: ProjectType
  date: DateTime
  target: TargetType!
  bank: BankDetailsType
  createdAt: DateTime!
  updatedAt: DateTime!
  supplier: PurchaseSupplierType
  conversion: PurchaseOrderConversionType
}

type GoogleColorType {
  textColor: String!
  backgroundColor: String!
}

type GmailHeaderType {
  name: String
  value: String
}

type GmailMessagePartBodyType {
  size: Int
  data: String
}

type GmailMessagePartType {
  partId: String
  mimeType: String
  filename: String
  headers: [GmailHeaderType!]
  body: GmailMessagePartBodyType
  parts: [GmailMessagePartType!]
}

type GmailMessageType {
  id: String
  threadId: String
  labelIds: [String!]
  snippet: String
  historyId: String
  internalDate: String
  payload: GmailMessagePartType
  sizeEstimate: Int
  raw: String
}

type GmailDraftType {
  id: String
  message: GmailMessageType
}

type GmailThreadType {
  id: String
  snippet: String
  historyId: String
  messages: [GmailMessageType!]
}

type GoogleDriveAboutUserType {
  kind: String
  displayName: String
  photoLink: String
  me: Boolean
  permissionId: String
  emailAddress: String
}

type GoogleDriveAboutStorageQuotaType {
  limit: String
  usage: String
  usageInDrive: String
  usageInDriveTrash: String
}

type GoogleDriveAboutTeamDriveThemesType {
  id: String
  backgroundImageLink: String
  colorRgb: String
}

type GoogleDriveFileCapabilitiesType {
  canAddChildren: Boolean
  canAddFolderFromAnotherDrive: Boolean
  canAddMyDriveParent: Boolean
  canChangeCopyRequiresWriterPermission: Boolean
  canChangeSecurityUpdateEnabled: Boolean
  canChangeViewersCanCopyContent: Boolean
  canComment: Boolean
  canCopy: Boolean
  canDelete: Boolean
  canDeleteChildren: Boolean
  canDownload: Boolean
  canEdit: Boolean
  canListChildren: Boolean
  canModifyContent: Boolean
  canModifyContentRestriction: Boolean
  canMoveChildrenOutOfTeamDrive: Boolean
  canMoveChildrenOutOfDrive: Boolean
  canMoveChildrenWithinTeamDrive: Boolean
  canMoveChildrenWithinDrive: Boolean
  canMoveItemIntoTeamDrive: Boolean
  canMoveItemOutOfTeamDrive: Boolean
  canMoveItemOutOfDrive: Boolean
  canMoveItemWithinTeamDrive: Boolean
  canMoveItemWithinDrive: Boolean
  canMoveTeamDriveItem: Boolean
  canReadRevisions: Boolean
  canReadTeamDrive: Boolean
  canReadDrive: Boolean
  canRemoveChildren: Boolean
  canRemoveMyDriveParent: Boolean
  canRename: Boolean
  canShare: Boolean
  canTrash: Boolean
  canTrashChildren: Boolean
  canUntrash: Boolean
}

type GoogleDriveTeamDrivePermissionDetailsType {
  teamDrivePermissionType: String
  role: String
  inheritedFrom: String
  inherited: Boolean
}

type GoogleDriveThumbnailType {
  image: String
  mimeType: String
}

type GoogleDriveContentHintsType {
  thumbnail: GoogleDriveThumbnailType
  indexableText: String
}

type GoogleDriveLocationType {
  latitude: Float
  longitude: Float
  altitude: Float
}

type GoogleDriveShortcutDetailsType {
  targetId: String
  targetMimeType: String
  targetResourceKey: String
}

type GoogleDriveLinkShareMetadataType {
  securityUpdateEligible: Boolean
  securityUpdateEnabled: Boolean
}

type GoogleDriveContentRestrictionsType {
  readOnly: Boolean
  reason: String
  restrictingUser: GoogleDriveAboutUserType
  restrictionTime: String
  type: String
}

type GoogleDriveImageMediaMetaDataType {
  width: Int
  height: Int
  rotation: Int
  location: GoogleDriveLocationType
  time: String
  cameraMake: String
  cameraModel: String
  exposureTime: Float
  aperture: Float
  flashUsed: Boolean
  focalLength: Float
  isoSpeed: Int
  meteringMode: String
  sensor: String
  exposureMode: String
  colorSpace: String
  whiteBalance: String
  exposureBias: Float
  maxApertureValue: Float
  subjectDistance: Int
  lens: String
}

type GoogleDriveFilePermissionsType {
  kind: String
  id: String
  type: String
  emailAddress: String
  domain: String
  role: String
  view: String
  allowFileDiscovery: Boolean
  displayName: String
  photoLink: String
  expirationTime: String
  teamDrivePermissionDetails: [GoogleDriveTeamDrivePermissionDetailsType!]
  permissionDetails: [GoogleDriveTeamDrivePermissionDetailsType!]
  deleted: Boolean
}

type GoogleDriveFileResourceType {
  kind: String
  id: String
  name: String
  mimeType: String
  description: String
  starred: Boolean
  trashed: Boolean
  explicitlyTrashed: Boolean
  trashingUser: GoogleDriveAboutUserType
  trashedTime: String
  spaces: [String!]
  webContentLink: String
  webViewLink: String
  iconLink: String
  hasThumbnail: Boolean
  thumbnailLink: String
  viewedByMe: Boolean
  viewedByMeTime: String
  createdTime: String
  modifiedTime: String
  modifiedByMeTime: String
  modifiedByMe: Boolean
  sharedWithMeTime: String
  sharingUser: GoogleDriveAboutUserType
  owners: [GoogleDriveAboutUserType!]
  teamDriveId: String
  driveId: String
  lastModifyingUser: GoogleDriveAboutUserType
  shared: Boolean
  ownedByMe: Boolean
  capabilities: GoogleDriveFileCapabilitiesType
  viewersCanCopyContent: Boolean
  copyRequiresWriterPermission: Boolean
  writersCanShare: Boolean
  permissions: [GoogleDriveFilePermissionsType!]
  permissionIds: [String!]
  hasAugmentedPermissions: Boolean
  folderColorRgb: String
  originalFilename: String
  fullFileExtension: String
  fileExtension: String
  md5Checksum: String
  headRevisionId: String
  contentHints: GoogleDriveContentHintsType
  imageMediaMetadata: GoogleDriveImageMediaMetaDataType
  isAppAuthorized: Boolean
  shortcutDetails: GoogleDriveShortcutDetailsType
  contentRestrictions: [GoogleDriveContentRestrictionsType!]
  resourceKey: String
  linkShareMetadata: GoogleDriveLinkShareMetadataType
}

type GoogleDriveBackgroundImageFileType {
  id: String
  xCoordinate: Float
  yCoordinate: Float
  width: Float
}

type GoogleDriveRestrictionsType {
  adminManagedRestrictions: Boolean
  copyRequiresWriterPermission: Boolean
  domainUsersOnly: Boolean
  driveMembersOnly: Boolean
}

type GoogleDriveTeamDriveResourceType {
  kind: String
  id: String
  name: String
  themeId: String
  colorRgb: String
  backgroundImageFile: GoogleDriveBackgroundImageFileType
  capabilities: GoogleDriveFileCapabilitiesType
  createdTime: String
  hidden: Boolean
  restrictions: GoogleDriveRestrictionsType
}

type GoogleDriveAboutChangesResourceType {
  kind: String
  type: String
  changeType: String
  time: String
  removed: Boolean
  fileId: String
  file: GoogleDriveFileResourceType
  teamDriveId: String
  driveId: String
  teamDrive: GoogleDriveTeamDriveResourceType
  drive: GoogleDriveTeamDriveResourceType
}

type GoogleCalendarDefaultReminderType {
  method: String!
  minutes: Int
}

type GoogleCalendarNotificationSettingsType {
  notifications: [GoogleCalendarNotificationSettingsNotificationType!]!
}

type GoogleCalendarNotificationSettingsNotificationType {
  type: String!
  method: String!
}

type GoogleCalendarConferencePropertiesType {
  allowedConferenceSolutionTypes: [String!]!
}

type GoogleCalendarListResourceType {
  kind: String!
  etag: String
  id: String
  summary: String
  description: String
  location: String
  timeZone: String
  summaryOverride: String
  colorId: String
  backgroundColor: String
  foregroundColor: String
  hidden: Boolean
  selected: Boolean
  accessRole: String
  defaultReminders: [GoogleCalendarDefaultReminderType!]
  notificationSettings: GoogleCalendarNotificationSettingsType
  primary: Boolean
  deleted: Boolean
  conferenceProperties: GoogleCalendarConferencePropertiesType
}

type GoogleCalendarBackForType {
  background: String!
  foreground: String
}

type GoogleCalendarEventCreatorType {
  id: String
  email: String
  displayName: String
  self: Boolean
}

type GoogleCalendarEventStartEndType {
  date: String
  dateTime: String
  timeZone: String
}

type GoogleCalendarEventAttendeeType {
  id: String
  email: String
  displayName: String
  organizer: Boolean
  self: Boolean
  resource: Boolean
  optional: Boolean
  responseStatus: String
  comment: String
  additionalGuests: Int
}

type GoogleCalendarEventConferenceDataCreateRequestSolutionKeyType {
  type: String
}

type GoogleCalendarEventConferenceDataCreateRequesStatusType {
  statusCode: String
}

type GoogleCalendarEventConferenceDataCreateRequestType {
  requestId: String
  conferenceSolutionKey: GoogleCalendarEventConferenceDataCreateRequestSolutionKeyType
  status: GoogleCalendarEventConferenceDataCreateRequesStatusType
}

type GoogleCalendarEventConferenceDataEntryPointsType {
  entryPointType: String
  uri: String
  label: String
  pin: String
  accessCode: String
  meetingCode: String
  passcode: String
  password: String
}

type GoogleCalendarEventConferenceDataConferenceSolutionKeyType {
  type: String
}

type GoogleCalendarEventConferenceDataConferenceSolutionType {
  key: GoogleCalendarEventConferenceDataConferenceSolutionKeyType
  name: String
  iconUri: String
}

type GoogleCalendarEventConferenceDataType {
  createRequest: GoogleCalendarEventConferenceDataCreateRequestType
  entryPoints: [GoogleCalendarEventConferenceDataEntryPointsType!]
  conferenceSolution: GoogleCalendarEventConferenceDataConferenceSolutionType
  conferenceId: String
  signature: String
  notes: String
}

type GoogleCalendarEventGadgetType {
  type: String
  title: String
  link: String
  iconLink: String
  width: Int
  height: Int
  display: String
}

type GoogleCalendarEventReminderOverridesType {
  method: String
  minutes: Float
}

type GoogleCalendarEventReminderType {
  useDefault: Boolean
  overrides: GoogleCalendarEventReminderOverridesType
}

type GoogleCalendarEventSourceType {
  url: String
  title: String
}

type GoogleCalendarEventAttachmentType {
  fileUrl: String
  title: String
  mimeType: String
  iconLink: String
  fileId: String
}

type GoogleCalendarEventType {
  kind: String
  etag: String
  id: String
  status: String
  htmlLink: String
  created: String
  updated: String
  summary: String
  description: String
  location: String
  colorId: String
  creator: GoogleCalendarEventCreatorType
  organizer: GoogleCalendarEventCreatorType
  start: GoogleCalendarEventStartEndType
  end: GoogleCalendarEventStartEndType
  endTimeUnspecified: Boolean
  recurrence: [String!]
  recurringEventId: String
  originalStartTime: GoogleCalendarEventStartEndType
  transparency: String
  visibility: String
  iCalUID: String
  sequence: Int
  attendees: [GoogleCalendarEventAttendeeType!]
  attendeesOmitted: Boolean
  hangoutLink: String
  conferenceData: GoogleCalendarEventConferenceDataType
  gadget: GoogleCalendarEventGadgetType
  anyoneCanAddSelf: Boolean
  guestsCanInviteOthers: Boolean
  guestsCanModify: Boolean
  guestsCanSeeOtherGuests: Boolean
  privateCopy: Boolean
  locked: Boolean
  reminders: GoogleCalendarEventReminderType
  source: GoogleCalendarEventSourceType
  attachments: [GoogleCalendarEventAttachmentType!]
  eventType: String
}

type GoogleCalendarSettingsType {
  kind: String
  etag: String
  id: String
  value: String
}

type SmsIntegrationType {
  messageId: String!
  statusMobile: String!
  statusMsg: String!
  statusCode: String!
}

type SmsLogType {
  id: ID!
  phone: IPhoneType
  validationNumber: Int
  createdAt: DateTime!
  updatedAt: DateTime!
}

type SEOAuditDataType {
  url: String
  title: String
  isLoaded: Boolean
  isGoogleAnalyticsObject: Boolean
  isGoogleAnalyticsFunc: Boolean
  isCharacterEncode: Boolean
  isMetaDescription: Boolean
  metaDescription: String
  isMetaDescriptionEnoughLong: Boolean
  isDoctype: Boolean
  isTitle: Boolean
  isTitleEnoughLong: Boolean
  isH1: Boolean
  h1: String
  isH1OnlyOne: Boolean
  isH2: Boolean
  linksCount: Int
  isTooEnoughLinks: Boolean
  internalNoFollowLinks: [String!]
  internalNoFollowLinksCount: Int
  notOptimizedImages: [String!]
  notOptimizedImagesCount: Int
  wordsCount: Int
  isContentEnoughLong: Boolean
  isViewport: Boolean
  isAmp: Boolean
  isNotIframe: Boolean
  pageIsBlocked: Boolean
  robotsFileExists: Boolean
  faviconExists: Boolean
  brokenLinksCount: Int
  brokenLinks: [String!]
  externalBrokenLinksCount: Int
  externalBrokenLinks: [String!]
  brokenImages: [String!]
  brokenImagesCount: Int
}

type InstagramProfileAuditDataLatestType {
  id: String
  type: String
  shortCode: String
  caption: String
  hashtags: [String!]
  mentions: [String!]
  url: String
  commentsCount: Float
  firstComment: String
  latestComments: [String!]
  dimensionsHeight: Float
  dimensionsWidth: Float
  displayUrl: String
  images: [String!]
  alt: String
  likesCount: Float
  timestamp: DateTime
  childPosts: [String!]
  ownerUsername: String
  ownerId: String
}

type InstagramProfileAuditDataIVGType {
  type: String
  shortCode: String
  title: String
  caption: String
  commentsCount: Float
  commentsDisabled: Boolean
  dimensionsHeight: Float
  dimensionsWidth: Float
  displayUrl: String
  likesCount: Float
  videoDuration: Float
  videoViewCount: Float
}

type InstagramProfileAuditDataType {
  id: String
  username: String
  fullName: String
  biography: String
  externalUrl: String
  externalUrlShimmed: String
  followersCount: Float
  followsCount: Float
  hasChannel: Boolean
  highlightReelCount: Float
  isBusinessAccount: Boolean
  joinedRecently: Boolean
  businessCategoryName: String
  private: Boolean
  verified: Boolean
  profilePicUrl: String
  profilePicUrlHD: String
  facebookPage: String
  igtvVideoCount: Float
  relatedProfiles: [String!]
  latestIgtvVideos: [InstagramProfileAuditDataIVGType!]
  postsCount: Float
  latestPosts: [InstagramProfileAuditDataLatestType!]
}

type FacebookProfileAuditMenuImagesPhotosOwnerType {
  id: String
  user_id: String
  additional_profile_has_taggable_products: Boolean
}

type FacebookProfileAuditMenuImagesPhotosImageType {
  uri: String
  width: Float
  height: Float
}

type FacebookProfileAuditMenuImagesPhotosType {
  id: String
  timestamp: Float
  ocrText: String
  image: FacebookProfileAuditMenuImagesPhotosImageType
  likes: Float
  isPlayable: Boolean
  owner: FacebookProfileAuditMenuImagesPhotosOwnerType
}

type FacebookProfileAuditMenuImagesType {
  id: String
  menu_image_title: String
  menu_photo: FacebookProfileAuditMenuImagesPhotosType
}

type FacebookProfileAuditMenuType {
  id: String
  share_page_menu_link: String
  structured_menu_program: String
  images: [FacebookProfileAuditMenuImagesType!]
}

type FacebookProfileAuditDeliverySettingsType {
  delivery_details: String
  id: String
}

type FacebookProfileAuditReviewUserType {
  id: String
  name: String
  profileUrl: String
  profilePic: String
}

type FacebookProfileAuditReviewType {
  id: String
  legacyId: String
  user: FacebookProfileAuditReviewUserType
  date: String
  url: String
  text: String
  likesCount: Float
  commentsCount: Float
}

type FacebookProfilePostsStatsType {
  likes: Float
  comments: Float
  shares: Float
}

type FacebookProfilePostsCommentsType {
  count: Float
}

type FacebookProfilePostsType {
  postDate: DateTime
  postText: String
  postsImages: [String!]
  postLinks: [String!]
  postUrl: String
  postStats: FacebookProfilePostsStatsType
  postComments: FacebookProfilePostsCommentsType
  postId: String
  timestamp: Float
  alt: String
}

type FacebookProfileAuditDataType {
  categories: [String!]
  info: [String!]
  likes: Float
  messenger: String
  posts: [FacebookProfilePostsType!]
  priceRange: String
  title: String
  pageUrl: String
  address: String
  payment: String
  pageId: String
  pageName: String
  phone: String
  email: String
  website: String
  services: String
  rating: String
  wifi: String
  reviews: [FacebookProfileAuditReviewType!]
  delivery_settings: FacebookProfileAuditDeliverySettingsType
  formatted_cuisines: String
  delivery_options: String
  menu: FacebookProfileAuditMenuType
  is_delegate_page_with_linked_profile: Boolean
  name: String
  impressum: [String!]
  instagram: String
  products: [String!]
  transit: String
  twitter: String
  youtube: String
  mission: [String!]
  overview: [String!]
  checkins: String
  verified: Boolean
}

type GoogleMapsAuditDataOrderType {
  name: String
  url: String
}

type GoogleMapsAuditDataReviewsType {
  oneStar: Float
  twoStar: Float
  threeStar: Float
  fourStar: Float
  fiveStar: Float
}

type GoogleMapsAuditDataLocationType {
  lat: Float
  lng: Float
}

type GoogleMapsAuditDataType {
  title: String
  subTitle: String
  price: String
  menu: String
  categoryName: String
  address: String
  locatedIn: String
  neighborhood: String
  street: String
  city: String
  postalCode: String
  state: String
  countryCode: String
  plusCode: String
  website: String
  phone: String
  temporarilyClosed: Boolean
  location: GoogleMapsAuditDataLocationType
  permanentlyClosed: Boolean
  totalScore: String
  isAdvertisement: Boolean
  rank: Float
  placeId: String
  categories: [String!]
  cid: String
  url: String
  searchPageUrl: String
  searchString: String
  scrapedAt: DateTime
  reviewsCount: Float
  reviewsDistribution: GoogleMapsAuditDataReviewsType
  reviews: [String!]
  orderBy: GoogleMapsAuditDataOrderType
}

type GoogleSearchAuditDataDebugType {
  requestId: String
  url: String
  method: String
  retryCount: Float
  errorMessages: [String!]
  statusCode: Float
  durationSecs: Float
}

type GoogleSearchAuditDataSearchQueryType {
  term: String
  device: String
  page: Float
  type: String
  domain: String
  countryCode: String
  languageCode: String
  locationUule: String
  resultsPerPage: String
}

type GoogleSearchAuditDataRelatedQueriesType {
  title: String
  url: String
}

type GoogleSearchAuditDataResultsProductType {
  price: String
  rating: Float
  numberOfReviews: Float
}

type GoogleSearchAuditDataSiteLinksType {
  title: String
  description: String
}

type GoogleSearchAuditDataResultsType {
  title: String
  url: String
  displayedUrl: String
  description: String
  emphasizedKeywords: [String!]
  siteLinks: [GoogleSearchAuditDataSiteLinksType!]
  productInfo: GoogleSearchAuditDataResultsProductType
}

type GoogleSearchAuditDataCustomDataType {
  pageTitle: String
}

type GoogleSearchAuditDataType {
  debug: GoogleSearchAuditDataDebugType
  error: Boolean
  searchQuery: GoogleSearchAuditDataSearchQueryType
  url: String
  hasNextPage: Boolean
  serpProviderCode: String
  resultsTotal: Float
  relatedQueries: [GoogleSearchAuditDataRelatedQueriesType!]
  paidResults: [GoogleSearchAuditDataResultsType!]
  paidProducts: [GoogleSearchAuditDataResultsType!]
  organicResults: [GoogleSearchAuditDataResultsType!]
  customData: GoogleSearchAuditDataCustomDataType
  htmlSnapshotUrl: String
}

type GoogleAnalyticsEventType {
  event: GARecommendedEventsEnum!
  active: Boolean!
}

enum GARecommendedEventsEnum {
  LOGIN
  SIGN_UP
  SEARCH
  SHARE
  EARN_VIRTUAL_CURRENCY
  SPEND_VIRTUAL_CURRENCY
  ADD_PAYMENT_INFO
  ADD_SHIPPING_INFO
  ADD_TO_CART
  ADD_TO_WISHLIST
  BEGIN_CHECKOUT
  GENERATE_LEAD
  PURCHASE
  REFUND
  REMOVE_FROM_CART
  SELECT_ITEM
  SELECT_PROMOTION
  VIEW_CART
  VIEW_ITEM
  VIEW_PROMOTION
}

type FBPixelEventType {
  event: PixelRecommendedEventsEnum!
  active: Boolean!
}

enum PixelRecommendedEventsEnum {
  ADD_PAYMENT_INFO
  ADD_TO_CART
  ADD_TO_WISHLIST
  COMPLETE_REGISTRATION
  CONTACT
  FIND_LOCATION
  INITIATE_CHECKOUT
  LEAD
  PURCHASE
  SCHEDULE
  SEARCH
  START_TRIAL
  SUBSCRIBE
  VIEW_CONTENT
}

type FBCatalogSyncAttributesType {
  active: Boolean!
  color: Boolean!
  gender: Boolean!
  size: Boolean!
  ageGroup: Boolean!
  material: Boolean!
  pattern: Boolean!
}

type FBCatalogSyncShippingType {
  active: Boolean!
  country: CountryType
  service: String
  price: String
}

type FigamyIntegrationAuthType {
  publicKey: String
  secretKey: String
}

type FigamyIntegrationAuthenticationLoginType {
  active: Boolean!
}

type FigamyIntegrationAuthenticationType {
  active: Boolean!
  appAuth: FigamyIntegrationAuthType
  figamyAuth: FigamyIntegrationAuthType
  login: FigamyIntegrationAuthenticationLoginType
}

type FigamyIntegrationWalletReputationType {
  active: Boolean!
  inactivityCycle: Boolean!
  lossAmount: Boolean!
  perks: Boolean!
}

type FigamyIntegrationWalletType {
  active: Boolean!
  quantitative: FigamyIntegrationAuthenticationLoginType
  qualitative: FigamyIntegrationAuthenticationLoginType
  reputation: FigamyIntegrationWalletReputationType
}

type FigamyIntegrationCatalogType {
  active: Boolean!
  auth: FigamyIntegrationAuthType
  syncTime: RecurrenceType
  sell: Boolean!
  sale: Boolean!
  shipping: Boolean!
}

type FigamyIntegrationDealsType {
  active: Boolean!
  monthlyAmount: String
  selfManaging: Boolean!
}

type FigamyIntegratioConverterType {
  active: Boolean!
  rate: String
}

type FigamyIntegratioMarketplaceType {
  active: Boolean
  paymentCycle: RecurrenceType
  comission: String
}

type TopChartCategoryItemType {
  key: String!
  value: String!
  cron: Boolean!
}

type TopChartGenreType {
  id: ID!
  platform: ChartPlatformEnum!
  category: TopChartCategoryItemType!
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum ChartPlatformEnum {
  IPHONE
  IPAD
  IOS
  ANDROID
  AMAZON
}

type AppFollowTopChartType {
  id: ID!
  date: DateTime
  country: String!
  genre: TopChartGenreType
  leaderboard: [TopChartLeaderboardType!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

type TopChartLeaderboardType {
  pos_diff: Float
  device: String
  genre_id: String
  icon: String
  country: String
  rating_avg: String
  feed_type: String
  price: String
  ext_id: String
  pos_curr: Float
  pos: Float
  url: String
  artist_name: String
  title: String
}

type AppTweakTopChartType {
  id: ID!
  date: DateTime
  country: CountryType!
  appType: ChartAppTypeEnum!
  genre: TopChartGenreType
  leaderboard: [AppTweakTopChartLeaderboardType!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum ChartAppTypeEnum {
  FREE
  PAID
  GROSSING
}

type AppTweakTopChartLeaderboardType {
  id: String
  title: String
  icon: String
  developer: String
  price: String
  genres: [String!]
  devices: [String!]
  slug: String
  rating: Float
  in_apps: Boolean
  ratings_count: Int
  power: Float
}

type ErpIntegrationEventType {
  event: ErpElementsEnum!
  active: Boolean!
}

enum ErpElementsEnum {
  PRODUCTS
  SERVICES
  EQUIPMENTS
  CUSTOMERS
  CONTACTS
  SUPPLIERS
  QUOTATIONS
  SALE_ORDERS
  SALE_INVOICES
  SALE_DELIVERY_NOTES
  SALE_ISSUE_NOTES
  PURCHASE_INVOICES
  PURCHASE_DELIVERY_NOTES
  PURCHASE_ORDERS
}

type QuestsCountType {
  total: Int!
  DRAFT: Int!
  ONGOING: Int!
  FINISHED: Int!
}

type QuestActionsCountType {
  total: Int!
  EXPIRED: Int!
  PERFORMED: Int!
  IN_PROGRESS: Int!
}

type QuestActivitiesCountType {
  total: Int!
}

type PerksType {
  discount: String!
  description: String
}

type LevelIntervalType {
  min: Int
  max: Int
}

type ReputationType {
  id: ID!
  reputationLevel: String
  lossAmount: Int!
  rank: Int!
  target: TargetType!
  picture: PictureType
  levelInterval: LevelIntervalType
  inactivityCycle: Int!
  nextLevelMax: Int
  perks: PerksType
  color: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ReputationWithoutTargetType {
  id: ID!
  reputationLevel: String
  lossAmount: Int!
  rank: Int!
  picture: PictureType
  levelInterval: LevelIntervalType
  inactivityCycle: Int!
  nextLevelMax: Int
  perks: PerksType
  color: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ReputationPaginateType {
  count: Int
  isLast: Boolean
  objects: [ReputationType!]!
}

type RemunerationWithReputationDtoType {
  qualitativeAmount: String!
  quantitativeAmount: String!
  reputationLevel: ReputationType
}

type QuestTypeType {
  id: ID!
  title: String
  description: String
  icon: String
  media: MediaType
  activityTypes: [ActivityTypeType!]
  maxActivities: Int
  rewardPoints: String
  minCoins: String
  fees: String
  score: Boolean
  profile: Boolean
  admin: Boolean
  transition: Boolean
  condition: Boolean
  enable: Boolean
  target: TargetType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type OwnerDtoType {
  pos: PointOfSaleType
  user: UserType
  wholesaler: WholesalerType
  manufacturer: ManufacturerType
}

type PocketWithoutTargetType {
  id: ID!
  usage: PocketUsageType!
  pocketType: PocketTypeEnum!
  amount: String
}

enum PocketUsageType {
  MAIN
  BONUS
}

enum PocketTypeEnum {
  QUANTITATIVE
  QUALITATIVE
}

type PocketType {
  id: ID!
  usage: PocketUsageType!
  pocketType: PocketTypeEnum!
  amount: String
  target: TargetType
}

type PocketWithReputationsType {
  id: ID!
  usage: PocketUsageType!
  pocketType: PocketTypeEnum!
  amount: String
  target: TargetType
  reputationLevels: [ReputationType!]
}

type WalletDtoType {
  id: ID!
  owner: OwnerDtoType
  createdAt: DateTime!
  updatedAt: DateTime!
  pockets: [PocketType!]
}

type WalletWithReputationDtoType {
  id: ID!
  owner: OwnerDtoType
  createdAt: DateTime!
  updatedAt: DateTime!
  pockets: [PocketWithReputationsType!]
}

type IsWalletAndCardInititalizedDtoType {
  isUserCardCreated: Boolean!
  isQuantitativeWalletCreated: Boolean!
}

type WalletLeaderboardType {
  user: UserType!
  rank: Int!
  amount: String!
  reputationLevel: ReputationType
}

type OwnerLessWalletOnePocketDtoType {
  id: ID!
  pocket: PocketType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type WalletOnePocketDtoType {
  id: ID!
  pocket: PocketType
  createdAt: DateTime!
  updatedAt: DateTime!
  owner: OwnerDtoType
}

type WalletOnePocketWithoutTargetDtoType {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  owner: OwnerDtoType
  pocket: PocketWithoutTargetType
}

type POSWithWalletType {
  id: ID!
  name: String
  title: String
  subtitle: String
  description: String
  tags: [String!]
  brandColor: String
  reference: String
  published: Boolean
  picture: PictureType
  outsidePictures: [PictureType!]
  insidePictures: [PictureType!]
  openingHours: OpeningHoursType
  specialOffers: [SpecialOfferType!]
  email: [String!]
  contactEmails: [String!]
  currency: Currency
  languages: [LanguageType!]
  phone: [String!]
  website: String
  chatContact: [SocialValueType!]
  socialMedia: [SocialValueType!]
  averageCustomers: Float
  turnover: String
  locations: [FullAddressType!]
  isFollowed: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
  posCategory: [POSCategoryType!]
  company: CompanyType
  services: [POSServicesType!]
  paymentMethods: [PaymentType!]
  loyaltyPrograms: [POSLoyaltyType!]
  wallet: OwnerLessWalletOnePocketDtoType
}

type POSWithWalletPaginateType {
  count: Int
  isLast: Boolean
  objects: [POSWithWalletType!]!
}

type WalletPaginateType {
  count: Int
  isLast: Boolean
  objects: [WalletDtoType!]!
}

type WalletOwnerHasEnoughBalanceType {
  hasEnoughBalance: Boolean!
}

type IsFollowedType {
  isFollowed: Boolean!
}

type FollowerType {
  id: ID!
  target: TargetType
  user: UserType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PointOfSaleWithFollowShipStatusType {
  id: ID!
  name: String
  title: String
  subtitle: String
  description: String
  tags: [String!]
  brandColor: String
  reference: String
  published: Boolean
  picture: PictureType
  outsidePictures: [PictureType!]
  insidePictures: [PictureType!]
  openingHours: OpeningHoursType
  specialOffers: [SpecialOfferType!]
  email: [String!]
  contactEmails: [String!]
  currency: Currency
  languages: [LanguageType!]
  phone: [String!]
  website: String
  chatContact: [SocialValueType!]
  socialMedia: [SocialValueType!]
  averageCustomers: Float
  turnover: String
  locations: [FullAddressType!]
  isFollowed: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
  posCategory: [POSCategoryType!]
  company: CompanyType
  services: [POSServicesType!]
  paymentMethods: [PaymentType!]
  loyaltyPrograms: [POSLoyaltyType!]
}

type FollowerPaginateType {
  count: Int
  isLast: Boolean
  objects: [FollowerType!]!
}

type PointOfSaleWithFollowShipStatusPaginateType {
  count: Int
  isLast: Boolean
  objects: [PointOfSaleWithFollowShipStatusType!]!
}

type EffectiveDateType {
  end: String!
  start: String!
}

type LeaderboardBaseType {
  user: UserType
  target: TargetType
  credit: String!
  rank: Int!
  rankDifference: Int!
  effectiveDate: EffectiveDateType!
  cycle: LeaderboardCycleEnum!
  currentReputationLevel: ReputationWithoutTargetType
  nextReputationLevel: ReputationWithoutTargetType
}

enum LeaderboardCycleEnum {
  OVERALL
  DAILY
  WEEKLY
  MONTHLY
}

type LeaderboardType {
  user: UserType
  target: TargetType
  credit: String!
  rank: Int!
  rankDifference: Int!
  effectiveDate: EffectiveDateType!
  cycle: LeaderboardCycleEnum!
  currentReputationLevel: ReputationWithoutTargetType
  nextReputationLevel: ReputationWithoutTargetType
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type IsUserSubscribedToTargetType {
  isSubscribed: Boolean!
  status: SubscriptionStatus
}

enum SubscriptionStatus {
  PENDING
  APPROVED
  REJECTED
}

type SubscribersFullType {
  id: ID!
  target: TargetType
  status: SubscriptionStatus
  createdAt: DateTime!
  updatedAt: DateTime!
  user: UserType
}

type SubscribersFullWithReputationType {
  id: ID!
  target: TargetType
  status: SubscriptionStatus
  createdAt: DateTime!
  updatedAt: DateTime!
  user: UserType
  wallet: WalletOnePocketWithoutTargetDtoType
  currentReputationLevel: ReputationWithoutTargetType
  nextReputationLevel: ReputationWithoutTargetType
}

type StatsType {
  numberOfProducts: Int!
  numberOfFollowers: Int!
  numberOfSubscribers: Int!
}

type SubscribersWithReputationsPaginateType {
  count: Int
  isLast: Boolean
  objects: [SubscribersFullWithReputationType!]!
}

type ProductWalletTopupType {
  name: String
  price: String
  tax: String
}

type WalletTopupFullType {
  id: ID
  pos: PointOfSaleType
  createdAt: DateTime!
  updatedAt: DateTime!
  executor: UserType
}

type OnsiteConverterType {
  id: ID!
  target: TargetType!
  remunerations: [RemunerationWithReputationDtoType!]!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PushAmountResponseType {
  source: TargetWithUserType!
  receiver: TargetWithUserType!
  qualitativeAmountPushed: String
  quantitativeAmountPushed: String!
}

type RemunerationAmountType {
  qualitativeAmountToPush: String!
  quantitativeAmountToPush: String!
}

type APICredentialsType {
  publicKey: String
  secretKey: String
}

type LoyaltySettingsOnsiteConverterIntgType {
  active: Boolean
  credentials: APICredentialsType
}

type LoyaltySettingsOnsiteConverterType {
  active: Boolean!
  onsiteConverter: OnsiteConverterType
  cashregisterIntegration: LoyaltySettingsOnsiteConverterIntgType
}

type LoyaltySettingsWalletType {
  active: Boolean!
  picture: PictureType
}

type LoyaltySettingsWalletCardType {
  digital: Boolean!
  physical: Boolean!
  validity: Int!
}

type LoyaltySettingsWalletLeaderboardType {
  active: Boolean!
  overall: Boolean!
  monthly: Boolean!
  weekly: Boolean!
}

type LoyaltySettingsWalletSubscribersType {
  verification: Boolean!
}

type LoyaltySettingsType {
  id: ID!
  qualitative: LoyaltySettingsWalletType
  quantitative: LoyaltySettingsWalletType
  onsiteConverter: LoyaltySettingsOnsiteConverterType
  loyaltyCard: LoyaltySettingsWalletCardType
  leaderboard: LoyaltySettingsWalletLeaderboardType
  subscribers: LoyaltySettingsWalletSubscribersType
  target: TargetType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ChallengeActionType {
  id: ID!
  label: String
  enable: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

type LabelType {
  id: ID!
  name: String!
  category: LabelTypeEnum
  icon: String
  color: String
  target: TargetType!
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum LabelTypeEnum {
  NOTES
  SCRUM
}

type NotesTaskType {
  title: String!
  done: Boolean
}

type BoardCardProcedureType {
  title: String
  task: BoardCardProcedureEnum
  time: DateTime
}

enum BoardCardProcedureEnum {
  MEETING
  CALL
  CONFERENCE
  DEMO
  CHAT
}

type BoardCardTasksType {
  task: String
  done: Boolean
}

type TasksStatsType {
  total: Int!
  done: Int!
}

type BoardCardForListType {
  id: ID!
  title: String!
  description: String
  dueDate: DateTime
  archived: Boolean
  priority: BoardCardPriorityEnum
  tags: [String!]
  pictures: [PictureType!]
  barcode: BarcodeType
  project: ProjectType
  tasks: [BoardCardTasksType!]
  labels: [LabelType!]
  rank: Int
  assignedTo: [UserType!]
  budget: String
  customer: CompanyType
  procedure: [BoardCardProcedureType!]
  attachments: [DocumentType!]
  tasksStats: TasksStatsType
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum BoardCardPriorityEnum {
  LOW
  NORMAL
  HIGH
  CRITICAL
}

type BoardCardType {
  id: ID!
  title: String!
  description: String
  dueDate: DateTime
  archived: Boolean
  priority: BoardCardPriorityEnum
  tags: [String!]
  pictures: [PictureType!]
  barcode: BarcodeType
  project: ProjectType
  tasks: [BoardCardTasksType!]
  labels: [LabelType!]
  rank: Int
  assignedTo: [UserType!]
  budget: String
  customer: CompanyType
  procedure: [BoardCardProcedureType!]
  attachments: [DocumentType!]
  tasksStats: TasksStatsType
  createdAt: DateTime!
  updatedAt: DateTime!
  boardList: BoardListType!
}

type BoardListType {
  id: ID!
  name: String!
  rank: Int
  theme: String
  identifier: MaintenanceBoardListEnum
  board: BoardType!
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum MaintenanceBoardListEnum {
  NEW_REQUEST
  IN_PROGRESS
  REPLACED
  SCRAP
}

type ListWithCardsType {
  id: ID!
  name: String!
  rank: Int
  theme: String
  identifier: MaintenanceBoardListEnum
  createdAt: DateTime!
  updatedAt: DateTime!
  boardCards: [BoardCardForListType!]
}

type BoardType {
  id: ID!
  title: String!
  description: String
  category: BoardCategoryEnum
  icon: String
  members: [UserType!]
  projects: [ProjectType!]
  target: TargetType!
  boardCardsStats: BoardCardsStatsType
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum BoardCategoryEnum {
  PROJECTS
  MAINTENANCE
  CRM
}

type TimeEntryType {
  id: ID!
  member: UserType!
  card: BoardCardType!
  start: DateTime!
  end: DateTime!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type GenericTaskType {
  id: ID!
  title: String!
  description: String
  tags: [String!]
  priority: TaskPriorityEnum!
  dueDate: DateTime
  completed: Boolean!
  archived: Boolean!
  rank: Int!
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum TaskPriorityEnum {
  HIGH
  NORMAL
  LOW
}

type TaskSectionType {
  id: ID!
  title: String!
  description: String
  tags: [String!]
  priority: TaskPriorityEnum!
  dueDate: DateTime
  completed: Boolean!
  archived: Boolean!
  rank: Int!
  createdAt: DateTime!
  updatedAt: DateTime!
  target: TargetType!
}

type TicketType {
  id: ID!
  identifier: String!
  name: String
  description: String
  media: MediaType
  tags: [String!]
  deadline: DateTime
  priority: TicketPriorityEnum
  status: TicketStatusEnum
  color: String
  assignedTo: [UserType!]
  customer: CompanyType
  project: ProjectType
  attachments: [DocumentType!]
  target: TargetType
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum TicketPriorityEnum {
  LOW
  NORMAL
  HIGH
  CRITICAL
}

enum TicketStatusEnum {
  OPEN
  IN_PROGRESS
  RESOLVED
  BLOCKED
  ON_HOLD
}

type CommentOnType {
  project: ProjectType
  card: BoardCardType
  ticket: TicketType
  quotation: QuotationType
  saleOrder: SaleOrderType
  saleIssueNote: SaleIssueNoteType
  saleInvoice: SaleInvoiceType
  saleDeliveryNote: SaleDeliveryNoteType
  purchaseDeliveryNote: PurchaseDeliveryNoteType
  purchaseInvoice: PurchaseInvoiceType
  purchaseOrder: PurchaseOrderType
}

type CommentBaseType {
  id: ID!
  user: UserType
  comment: String
  attachments: [DocumentType!]
  holder: CommentOnType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type FirstReplyType {
  reply: CommentBaseType
  hasMoreReplies: Boolean!
}

type CommentType {
  id: ID!
  user: UserType
  comment: String
  attachments: [DocumentType!]
  holder: CommentOnType
  createdAt: DateTime!
  updatedAt: DateTime!
  firstReply: FirstReplyType
}

type TimeTrackOnType {
  project: ProjectType
  card: BoardCardType
  ticket: TicketType
}

type TimeTrackType {
  id: ID!
  user: UserType
  title: String
  start: DateTime
  end: DateTime
  idle: String
  holder: TimeTrackOnType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PriceDtoType {
  net: ReduciblePriceType
  gross: ReduciblePriceType
}

type OrderCompanyContactDetailsType {
  email: String
}

type OrderCompanyLegalType {
  vat: String
  register: String
  licence: String
}

type OrderCompanyType {
  id: ID!
  name: String
  address: FullAddressType
  legal: OrderCompanyLegalType
  contact: OrderCompanyContactDetailsType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type POSCategoryOrderType {
  id: ID!
  name: String
}

type OrderPOSType {
  id: String!
  title: String!
  email: [String!]!
  phone: [String!]!
  website: String
  outsidePictures: [PictureType!]
  insidePictures: [PictureType!]
  posCategory: [POSCategoryOrderType!]
  extraDeliveryFees: Float
  currency: Currency
  address: FullAddressType
  company: OrderCompanyType
}

type OrderInnerProductType {
  id: ID!
  name: String!
  tax: String!
}

type OrderProductType {
  product: OrderInnerProductType!
  barcode: BarcodeBaseRawType!
  quantity: Int!
  taxValue: TaxValueType!
  price: ProductPriceType!
}

type OwnerOrTargetDtoType {
  wholesaler: WholesalerType
  manufacturer: ManufacturerType
}

type OrderType {
  id: ID!
  orderNumber: Float!
  user: UserType
  installments: [InstallmentType!]
  orderType: OrderTypeEnum!
  status: OrderStatus!
  orderProducts: [OrderProductType!]!
  pos: OrderPOSType!
  target: OwnerOrTargetDtoType!
  price: PriceDtoType!
  paymentStatus: PaymentStatusEnum!
  taxValue: ReduciblePriceType!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type OrderPaginateType {
  count: Int
  isLast: Boolean
  objects: [OrderType!]!
}

type CatalogueCategoryWithTotalAmountType {
  id: ID!
  name: String
  description: String
  externalId: String
  pictures: [PictureType!]
  variety: ProductVarietyEnum
  parent: CatalogueCategoryBaseType
  portal: Boolean
  pickup: Boolean
  booking: Boolean
  delivery: Boolean
  hasChildren: Boolean!
  rank: Int
  layer: Int!
  seo: CatalogueCategorySeoType
  createdAt: DateTime!
  updatedAt: DateTime!
  target: TargetType!
  totalAmount: String!
}

type TotalAmountType {
  totalAmount: String!
  byCatalogueCategory: [CatalogueCategoryWithTotalAmountType!]!
}

type InternalProductWithSalesStatsType {
  id: ID!
  name: String
  salesValue: String
  totalQuantities: Int
}

type SalesStatsType {
  salesValue: String
  salesPercentage: String
  products: [InternalProductWithSalesStatsType!]
}

type CategoryWithSalesStatsType {
  salesValue: String
  salesPercentage: String
  products: [InternalProductWithSalesStatsType!]
  id: ID!
  name: String
}

type GetProductsStatsWithFilterResponseType {
  totalSales: String!
  otherCategories: SalesStatsType!
  categories: [CategoryWithSalesStatsType!]!
}

type GetOrdersStatsWithFilterResponseType {
  totalOrderPrices: String!
  totalObjectives: String!
  paidInstallments: String!
  totalInstallments: String!
  installmentsCredit: String!
  gap: String!
  percentage: String!
}

type GetOrdersCountByStatusWithFilterResponseType {
  CANCELED: Int!
  SUCCESS: Int!
  PENDING: Int!
}

type MinMaxDateType {
  min: DateTime!
  max: DateTime!
}

type TotalByDateType {
  total: Float!
  date: MinMaxDateType!
}

type GetOrdersRevenueStatsWithFilterResponseType {
  total: String!
  current: [TotalByDateType!]!
  previous: [TotalByDateType!]!
}

type GetVisitsStatsResponseType {
  total: Int
  sales: Int
  others: Int
  salesPercentage: String!
  othersPercentage: String!
}

type PointOfSaleWithInstallmentsType {
  id: ID!
  name: String
  title: String
  subtitle: String
  description: String
  tags: [String!]
  brandColor: String
  reference: String
  published: Boolean
  picture: PictureType
  outsidePictures: [PictureType!]
  insidePictures: [PictureType!]
  openingHours: OpeningHoursType
  specialOffers: [SpecialOfferType!]
  email: [String!]
  contactEmails: [String!]
  currency: Currency
  languages: [LanguageType!]
  phone: [String!]
  website: String
  chatContact: [SocialValueType!]
  socialMedia: [SocialValueType!]
  averageCustomers: Float
  turnover: String
  locations: [FullAddressType!]
  isFollowed: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
  posCategory: [POSCategoryType!]
  company: CompanyType
  services: [POSServicesType!]
  paymentMethods: [PaymentType!]
  loyaltyPrograms: [POSLoyaltyType!]
  paidInstallments: String
  installmentsCredit: String
  totalInstallments: String
}

type PointOfSaleWithInstallmentsPaginateType {
  count: Int
  isLast: Boolean
  objects: [PointOfSaleWithInstallmentsType!]!
}

type CalendarType {
  id: ID!
  start: DateTime!
  end: DateTime!
  color: String
  leaveType: LeaveTypeEnum!
  user: UserType
  target: TargetType!
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum LeaveTypeEnum {
  TRAVEL
  WEEKEND
  DAY_OFF
  NURSING
  VACATION
  SICKNESS
  SHIFT_WORK
  HOME_OFFICE
  WORK_ACCIDENT
}

type PaginatedCalendarsType {
  count: Int
  isLast: Boolean
  objects: [CalendarType!]!
}

type WeatherIconsDetailType {
  day: String
  night: String
}

type WeatherIconsType {
  id: ID!
  code: Float
  description: String
  icon: WeatherIconsDetailType
  iconify: WeatherIconsDetailType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type WeatherIconsPaginateType {
  count: Int
  isLast: Boolean
  objects: [WeatherIconsType!]!
}

type WeatherDetailType {
  description: String
  code: Float
  icon: String
}

type WeatherType {
  id: ID!
  app_temp: Float
  aqi: Float
  city_name: String
  clouds: String
  country_code: String
  datetime: String
  dewpt: Float
  dhi: Float
  dni: Float
  elev_angle: Float
  ghi: Float
  gust: String
  h_angle: Float
  lat: Float
  lon: Float
  ob_time: DateTime
  pod: String
  precip: Float
  pres: Float
  rh: Float
  slp: Float
  snow: Float
  solar_rad: Float
  state_code: String
  station: String
  sunrise: String
  sunset: String
  temp: Float
  timezone: String
  ts: Float
  uv: Float
  vis: Float
  weather: WeatherDetailType
  wind_cdir: String
  wind_cdir_full: String
  wind_dir: Float
  wind_spd: Float
  createdAt: DateTime!
  updatedAt: DateTime!
}

type WeatherWithIconType {
  id: ID!
  city_name: String
  country_code: String
  datetime: String
  sunrise: String
  sunset: String
  temp: Float
  timezone: String
  weather: WeatherIconsType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type WeatherPaginateType {
  count: Int
  isLast: Boolean
  objects: [WeatherType!]!
}

type POSBundleType {
  id: ID!
  targets: [PointOfSaleType!]!
  owner: OwnerOrTargetDtoType!
  name: String!
  reduction: String!
  conversionRate: Int
}

type POSBundlePaginateType {
  count: Int
  isLast: Boolean
  objects: [POSBundleType!]!
}

type DistributionNetworkOwnerType {
  wholesaler: WholesalerType
  manufacturer: ManufacturerType
  user: UserType
}

type DistributionNetworkType {
  id: ID!
  targets: [DistributionNetworkTargetType!]!
  owner: DistributionNetworkOwnerType!
}

type DistributionNetworkTargetType {
  pos: PointOfSaleType!
  reference: String!
}

type PointOfSaleWithReferenceType {
  id: ID!
  name: String
  title: String
  subtitle: String
  description: String
  tags: [String!]
  brandColor: String
  reference: String
  published: Boolean
  picture: PictureType
  outsidePictures: [PictureType!]
  insidePictures: [PictureType!]
  openingHours: OpeningHoursType
  specialOffers: [SpecialOfferType!]
  email: [String!]
  contactEmails: [String!]
  currency: Currency
  languages: [LanguageType!]
  phone: [String!]
  website: String
  chatContact: [SocialValueType!]
  socialMedia: [SocialValueType!]
  averageCustomers: Float
  turnover: String
  locations: [FullAddressType!]
  isFollowed: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
  posCategory: [POSCategoryType!]
  company: CompanyType
  services: [POSServicesType!]
  paymentMethods: [PaymentType!]
  loyaltyPrograms: [POSLoyaltyType!]
  distance: Float
}

type IsPosAssignedToOwnerType {
  isAssigned: Boolean!
}

type DistributionNetworkPaginateType {
  count: Int
  isLast: Boolean
  objects: [DistributionNetworkType!]!
}

type DistributionNetworkTargetPaginateType {
  count: Int
  isLast: Boolean
  objects: [DistributionNetworkTargetType!]!
}

type DistributionNetworkOwnersPaginateType {
  count: Int
  isLast: Boolean
  objects: [DistributionNetworkOwnerType!]!
}

type PointOfSaleWithReferencePaginateType {
  count: Int
  isLast: Boolean
  objects: [PointOfSaleWithReferenceType!]!
}

type SalesObjectiveType {
  value: String!
  start: DateTime!
  end: DateTime!
}

type TeamSettingsType {
  id: ID!
  color: String
  salesObjective: SalesObjectiveType
  user: UserType
  target: TargetType!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PaginatedTeamSettingsType {
  count: Int
  isLast: Boolean
  objects: [TeamSettingsType!]!
}

type CheckinTypeStatsType {
  checkinType: CheckinTypeWithAllEnum!
  count: Int!
}

enum CheckinTypeWithAllEnum {
  ALL
  SALE
  RECOVERY
  PROSPECTION
  GENERAL_VISIT
}

type CheckinActivityOwnerType {
  wholesaler: WholesalerType
  manufacturer: ManufacturerType
}

type CheckinActivityType {
  id: ID!
  checkinType: CheckinTypeEnum!
  description: String!
  user: UserType!
  owner: CheckinActivityOwnerType!
  pos: PointOfSaleType!
  checkin: DateTime!
  checkout: DateTime
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum CheckinTypeEnum {
  GENERAL_VISIT
  SALE
  PROSPECTION
  RECOVERY
}

type CheckinActivityPaginateType {
  count: Int
  isLast: Boolean
  objects: [CheckinActivityType!]!
}

type PaginatedCheckinActivityWithStatsType {
  count: Int
  isLast: Boolean
  objects: [CheckinActivityType!]!
  stats: [CheckinTypeStatsType!]
}

type IsProductInMobileWarehouseType {
  quantity: Int!
  inMobileWarehouse: Boolean!
}

type InternalProductWithoutProductOrBarcodesType {
  id: ID
  name: String
  description: String
  descriptionList: [String!]
  specs: [ProductSpecsType!]
  externalId: String
  tags: [String!]
  sku: String
  condition: ProductConditionEnum
  status: ProductStatusEnum
  picture: PictureType
  pictures: [PictureType!]
  media: MediaType
  structure: ProductStructureEnum
  rent: Boolean
  variety: ProductVarietyEnum
  price: String
  priceBeforeReduction: String
  discount: DiscountDtoType
  target: TargetType!
  catalogueCategory: [CatalogueCategoryType!]
  globalCategory: GlobalCategoryProductType
  tax: String
  seo: CatalogueCategorySeoType
  brand: BrandType
  createdAt: DateTime!
  updatedAt: DateTime!
  class: [ProductClassEnum!]
}

type LocalStockType {
  barcode: BarcodeType!
  quantity: Int!
}

type MobileWarehouseType {
  id: ID!
  user: UserType!
  stock: [LocalStockType!]!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type StockWithInternalProductType {
  barcode: BarcodeType!
  internalProduct: InternalProductWithoutProductOrBarcodesType!
  quantity: Int!
}

type MobileWarehouseWithInternalProductType {
  id: ID!
  user: UserType!
  stock: [StockWithInternalProductType!]!
}

type MobileWarehouseWithInternalProductPaginateType {
  count: Int
  isLast: Boolean
  objects: [MobileWarehouseWithInternalProductType!]!
}

type StockWithInternalProductPaginateType {
  count: Int
  isLast: Boolean
  objects: [StockWithInternalProductType!]!
}

type ChargeDischargeType {
  id: ID!
  user: UserType!
  createdAt: DateTime!
  updatedAt: DateTime!
  executor: UserType!
  chargeType: ChargeDischargeEnum!
  stock: [LocalStockType!]!
}

enum ChargeDischargeEnum {
  CHARGE
  DISCHARGE
}

type ChargeDischargeWithInternalProductType {
  id: ID!
  user: UserType!
  executor: UserType!
  chargeType: ChargeDischargeEnum!
  createdAt: DateTime!
  updatedAt: DateTime!
  stock: [StockWithInternalProductType!]!
}

type ChargeDischargePaginateType {
  count: Int
  isLast: Boolean
  objects: [ChargeDischargeType!]!
}

type ChargeDischargeWithInternalProductsPaginateType {
  count: Int
  isLast: Boolean
  objects: [ChargeDischargeWithInternalProductType!]!
}

type IntegrationSettingsType {
  id: ID!
  target: OwnerOrTargetDtoType!
  url: String!
  username: String!
  password: String
}

type IntegrationSettingsPaginateType {
  count: Int
  isLast: Boolean
  objects: [IntegrationSettingsType!]!
}

type PosAttributesGeneralType {
  heetsHandler: Boolean!
  nLicences: Int!
}

type PosAttributesCriteriaTrafficType {
  consumer: PosAttributesTrafficEnum!
  wholesaler: PosAttributesTrafficEnum!
}

enum PosAttributesTrafficEnum {
  LOW
  MEDIUM
  HIGH
}

type PosAttributesCriteriaType {
  location: PosAttributesLocationEnum!
  traffic: PosAttributesCriteriaTrafficType!
}

enum PosAttributesLocationEnum {
  RURAL
  MEDIUM
  PREMIUM
}

type PosAttributesDteType {
  code: String!
  hypercare: Boolean!
}

type PosAttributesVolumeHandlerType {
  monthlyCc: Float!
  monthlyRrp: Float!
}

type PosAttributesVolumeType {
  handlerQuantity: PosAttributesVolumeHandlerType!
}

type PosAttributesType {
  id: ID!
  general: PosAttributesGeneralType!
  criteria: PosAttributesCriteriaType!
  dte: PosAttributesDteType!
  volume: PosAttributesVolumeType!
  pos: PointOfSaleType!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PaginatedPosAttributesType {
  count: Int
  isLast: Boolean
  objects: [PosAttributesType!]!
}

type VisibilitySectionType {
  id: ID!
  title: String
  description: String
  icon: String
  media: MediaType
  owner: VisibilityOwnerEnum!
  target: TargetType
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum VisibilityOwnerEnum {
  MAIN
  COMPETITION
}

type PaginatedVisibilitySectionType {
  count: Int
  isLast: Boolean
  objects: [VisibilitySectionType!]!
}

type VisibilityClassificationType {
  id: ID!
  title: String!
  description: String
  icon: String
  media: MediaType
  sections: [VisibilitySectionType!]
  flag: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PaginatedVisibilityClassificationType {
  count: Int
  isLast: Boolean
  objects: [VisibilityClassificationType!]!
}

type VisibilityItemType {
  id: ID!
  title: String!
  description: String
  icon: String
  media: MediaType
  classification: VisibilityClassificationType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PaginatedVisibilityItemType {
  count: Int
  isLast: Boolean
  objects: [VisibilityItemType!]!
}

type PosVisibilityItemValueType {
  item: [VisibilityItemType!]
  flag: Boolean
}

type PosVisibilityItemType {
  classification: VisibilityClassificationType!
  value: PosVisibilityItemValueType!
}

type PosVisibilityType {
  id: ID!
  section: VisibilitySectionType!
  target: TargetType
  pos: PointOfSaleType!
  items: [PosVisibilityItemType!]!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PaginatedPosVisibilityType {
  count: Int
  isLast: Boolean
  objects: [PosVisibilityType!]!
}

type MerchDataTypeType {
  id: ID!
  title: String!
  description: String
  icon: String
  media: MediaType
  target: TargetType!
  product: Boolean!
  categories: [POSCategoryType!]!
  enable: Boolean!
  recurrence: RecurrenceType!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PaginatedMerchDataTypeType {
  count: Int
  isLast: Boolean
  objects: [MerchDataTypeType!]!
}

type MerchDataPeriodType {
  start: DateTime!
  end: DateTime!
}

type MerchDataType {
  id: ID!
  datatype: MerchDataTypeType!
  pos: PointOfSaleType!
  article: BarcodeType!
  value: String!
  period: MerchDataPeriodType!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PaginatedMerchDataType {
  count: Int
  isLast: Boolean
  objects: [MerchDataTypeType!]!
}

type Query {
  loginForApp(input: LoginInput!): LoginType!
  login(input: LoginInput!): LoginType!
  loginWithFacebook(token: String!): LoginType!
  loginWithGoogle(token: String!): LoginType!
  loginWithApple(authorizationData: AuthorizationDataInput!): LoginType!
  getVersions: [VersionType!]!
  getVersion(id: String!): VersionType!
  getByVersion(version: String!): VersionType!
  getLastVersion: VersionType!
  getLastVersionByPlatform(platform: PlatformEnum!): VersionType!
  getVersionsPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): VersionsPaginateType!
  findGlobalCategoryById(id: ID!): GlobalCategoryType!
  findGlobalCategoriesPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): GlobalCategoryPaginatedType!
  findGlobalCategoryByProviderAndIdentifier(
    identifier: Int!
    provider: GlobalCategoryProviderEnum!
  ): GlobalCategoryType!
  findGlobalCategoriesByProviderPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
    provider: GlobalCategoryProviderEnum!
  ): GlobalCategoryPaginatedType!
  getUsersPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): UserPaginateType!
  getRoles: StringListType!
  getGenders: StringListType!
  getMaritalStatuses: StringListType!
  getUsers: [UserType!]!
  getUsersPaginated(
    status: [UserStatus!]
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): UserPaginateType!
  user(id: String!): UserType!
  currentUser: UserType!
  userByEmail(email: String!): UserType!
  searchUser(
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
  ): UserPaginateType!
  isLoggedIn: IsLoggedInType!
  isLoginExist(input: IsLoginExistInput!): UserExistType!
  isEmailExist(email: String!): UserExistType!
  getVapidKey(userId: String): VapidKeyType!
  getUsersLocations: [UserLocationType!]!
  getUserLocation(id: String!): UserLocationType!
  findCurrentUserLocation: UserLocationType!
  userCardByUser(userId: String!): UserLocationType!
  requestLocations(target: TargetACIInput!): TargetIdsType!
  getTaxes: [TaxType!]!
  tax(id: ID!): TaxType!
  getTaxesByCompany(company: ID!): [TaxType!]!
  getGlobalSalesTaxesByCompany(company: ID!): [TaxType!]!
  getGlobalPurchasesTaxesByCompany(company: ID!): [TaxType!]!
  getProductSalesTaxesByCompany(company: ID!): [TaxType!]!
  getProductPurchasesTaxesByCompany(company: ID!): [TaxType!]!
  getTaxesByCompanyPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
    company: ID!
  ): TaxPaginateType!
  getBrandsPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): BrandPaginateType!
  getBrands: [BrandType!]!
  getBrandsByTarget(target: TargetACIInput!): [BrandType!]!
  getBrandsByTargetPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
    target: TargetACIInput!
  ): BrandPaginateType!
  brand(id: String!): BrandType!
  searchBrand(
    target: TargetACIInput
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
  ): BrandPaginateType!
  findBrandByExternalIdAndTarget(
    target: TargetACIInput
    externalId: String!
  ): BrandType!
  getOrigins: [OriginType!]!
  getCompaniesPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): CompanyPaginateType!
  getCompanies: [CompanyType!]!
  company(id: ID!): CompanyType!
  searchCompany(
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
  ): CompanyPaginateType!
  searchCustomersByTargetAndPhase(
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
    phase: CustomerPhaseEnum!
    target: TargetACIInput!
  ): CompanyPaginateType!
  searchSuppliersByTarget(
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
    kinds: [SupplierTypeEnum!]
    target: TargetACIInput!
  ): CompanyPaginateType!
  searchLogisticCompaniesByTarget(
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
    target: TargetACIInput!
  ): CompanyPaginateType!
  getCustomers(
    pagination: PaginationInput = { page: 0, limit: 20 }
    phase: CustomerPhaseEnum!
    target: TargetACIInput!
  ): CompanyPaginateType!
  getCompaniesByTarget(
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
    target: TargetACIInput!
  ): CompanyPaginateType!
  getPriceTypes: StringListType!
  getProductsPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): ProductPaginateType!
  getProducts: [ProductType!]!
  getProductsByCategoryPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
    category_ids: [String!]!
  ): ProductPaginateType!
  getProductsByClass(
    pagination: PaginationInput = { page: 0, limit: 20 }
    class: [ProductClassEnum!]!
  ): ProductPaginateType!
  product(id: String!): ProductType!
  findOneByEAN(ean: String!): ProductType!
  searchProduct(
    catId: String
    searchString: String
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): ProductPaginateType!
  getProductWithFilter(
    pagination: PaginationInput = { page: 0, limit: 20 }
    sort: [ProductSortInput!]
    filter: ProductFilterInput
  ): ProductPaginateWithFilterType!
  getBarcodesPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): BarcodePaginateType!
  getBarcodes: [BarcodeType!]!
  barcode(id: String!): BarcodeType!
  getBarcodeWithStock(id: String!): BarcodeWithStockType!
  getBarcodeByProductAndAttributes(input: BarcodeFindInput!): BarcodeType!
  getProductBarcodes(productId: String!): [BarcodeType!]!
  getAccounts(
    target: TargetACIInput
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): AccountPaginateType!
  getWaitersByPoss(
    pagination: PaginationInput = { page: 0, limit: 20 }
    posId: String!
  ): AccountPaginateType!
  getDeliveryManByPos(
    pagination: PaginationInput = { page: 0, limit: 20 }
    posId: String!
  ): AccountPaginateType!
  getAccountsByTargetAndRoles(
    pagination: PaginationInput = { page: 0, limit: 20 }
    role: [UserRole!]!
    target: TargetACIInput!
  ): AccountPaginateType!
  account(id: String!): AccountType!
  accountByUserId(userId: String!): AccountType!
  currentAccount: AccountType!
  searchAccount(
    target: TargetACIInput!
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
  ): AccountPaginateType!
  getAttributesPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): AttributePaginateType!
  getAttributesTargetPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
    target: TargetACIInput!
  ): AttributePaginateType!
  getAttributes: [AttributeType!]!
  getAttributesByTarget(target: TargetACIInput!): [AttributeType!]!
  attribute(id: String!): AttributeType!
  searchAttribute(
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
  ): AttributePaginateType!
  searchAttributeByTarget(
    pagination: PaginationInput = { page: 0, limit: 20 }
    variety: ProductVarietyEnum
    target: TargetACIInput!
    searchString: String
  ): AttributePaginateType!
  findAttributeByExternalIdAndTarget(
    target: TargetACIInput
    externalId: String!
  ): AttributeType!
  getAttributeValuesPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): AttributeValuePaginateType!
  getAttributeValuesByTargetPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
    target: TargetACIInput!
  ): AttributeValuePaginateType!
  getAttributeValues: [AttributeValueType!]!
  getAttributeValuesByTarget(target: TargetACIInput!): [AttributeValueType!]!
  getAttributeValuesByAttribute(attributId: ID!): [AttributeValueType!]!
  getAttributeValuesByAttributePaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
    attributId: ID!
  ): AttributeValuePaginateType!
  attributeValue(id: ID!): AttributeValueType!
  searchAttributeValue(
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
  ): AttributeValuePaginateType!
  searchAttributeValueByTarget(
    target: TargetACIInput!
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
  ): AttributeValuePaginateType!
  findAttributeValueByExternalIdAndTarget(
    target: TargetACIInput
    externalId: String!
  ): AttributeValueType!
  getWholesalersPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): WholesalerPaginateType!
  getWholesalers: [WholesalerType!]!
  wholesaler(id: String!): WholesalerType!
  searchWholesaler(
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
  ): WholesalerPaginateType!
  getPOSCategoriesPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): POSCategoryPaginateType!
  getPOSCategories: [POSCategoryType!]!
  posCategory(id: String!): POSCategoryType!
  searchPosCategory(
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
  ): POSCategoryPaginateType!
  getOpeningStatuses: StringListType!
  getSpecialOffersTypes: StringListType!
  getPointOfSalesPagination(
    posCategory: ID
    published: Boolean
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): PointOfSalePaginateType!
  pointOfSale(id: ID!): PointOfSaleType!
  pointOfSaleByOrigin(website: String): PointOfSaleType!
  searchPos(
    published: Boolean
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
  ): PointOfSalePaginateType!
  findPOSNearbyPagination(
    categoryId: ID
    published: Boolean
    pagination: PaginationInput = { page: 0, limit: 20 }
    rad: Float!
    lat: Float!
    lon: Float!
  ): PointOfSalePaginateType!
  searchPOSNearbyPagination(
    categoryId: ID
    published: Boolean
    searchString: String!
    pagination: PaginationInput = { page: 0, limit: 20 }
    rad: Float!
    lat: Float!
    lon: Float!
  ): PointOfSalePaginateType!
  getPOSWithFollowersPagination(
    published: Boolean
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): PointOfSaleWithFollowShipStatusPaginateType!
  findPOSNearbyWithFollowersPagination(
    categoryId: String
    pagination: PaginationInput = { page: 0, limit: 20 }
    rad: Float!
    lat: Float!
    lon: Float!
  ): PointOfSaleWithFollowShipStatusPaginateType!
  isUserNearPOS(posId: ID!, lat: Float!, lon: Float!): IsUserNearPOSDtoType!
  getPOSServicesPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): POSServicesPaginateType!
  getPOSservices: [POSServicesType!]!
  posServices(id: String!): POSServicesType!
  searchPosServices(
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
  ): POSServicesPaginateType!
  getManufacturersPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): ManufacturerPaginateType!
  manufacturer(id: String!): ManufacturerType!
  searchManufacturer(
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
  ): ManufacturerPaginateType!
  getStaticData: [StaticDataType!]!
  getStaticDataByKey(key: String!): StaticDataType!
  getLoyaltyProgramsPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): LoyaltyProgramPaginateType!
  loyaltyProgram(id: String!): LoyaltyProgramType!
  searchLoyaltyProgram(
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
  ): LoyaltyProgramPaginateType!
  getMobileWarehouses(target: OwnerOrTargetInput!): [MobileWarehouseType!]!
  getMobileWarehousePagination(
    target: OwnerOrTargetInput!
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): MobileWarehouseWithInternalProductPaginateType!
  getMobileWarehouseWithInternalProduct(
    id: ID!
  ): MobileWarehouseWithInternalProductType!
  getMobileWarehouseByExcel(
    path: String
    target: OwnerOrTargetInput!
  ): InvoicePDFType!
  getMobileWarehouse(id: String!): MobileWarehouseType!
  isProductInMobileWarehouse(barcode: String!): IsProductInMobileWarehouseType!
  getInternalProductFromMobileWarehouse(
    merchandiserId: ID
    target: OwnerOrTargetInput!
    barcode: ID!
  ): StockWithInternalProductType!
  getMobileWarehouseProducts(
    merchandiserId: String
    searchString: String
    target: OwnerOrTargetInput!
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): StockWithInternalProductPaginateType!
  getWarehouses: [WarehouseType!]!
  warehouse(id: ID!): WarehouseType!
  getWarehousesByCompany(company: ID!): [WarehouseType!]!
  getWarehousesByCompanyPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
    company: ID!
  ): WarehousePaginateType!
  findWarehousesByLocation(location: ID!): [WarehouseType!]!
  findWarehousesByLocationPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
    location: ID!
  ): WarehousePaginateType!
  getLocations: [LocationType!]!
  location(id: ID!): LocationType!
  getLocationsByCompany(company: ID!): [LocationType!]!
  getLocationsByCompanyPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
    filter: LocationFilterInput
    company: ID!
  ): LocationPaginateType!
  getProductAttributesPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): ProductAttributePaginateType!
  getProductAttributesByTargetPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
    target: TargetACIInput!
  ): ProductAttributePaginateType!
  getProductAttributes: [ProductAttributeType!]!
  getProductAttributesByTarget(
    target: TargetACIInput!
  ): [ProductAttributeType!]!
  getProductAttributesByAttribute(attributId: String!): [ProductAttributeType!]!
  getProductAttributesByAttributeAndTarget(
    target: TargetACIInput!
    attributId: String!
  ): [ProductAttributeType!]!
  productAttribute(id: String!): ProductAttributeType!
  searchProductAttribute(
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
  ): ProductAttributePaginateType!
  searchProductAttributeByTarget(
    target: TargetACIInput!
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
  ): ProductAttributePaginateType!
  getInventoryCategoriesPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): InventoryCategoryPaginateType!
  getInventoryCategories: [InventoryCategoryType!]!
  getInventoryCategoriesByLayerandParent(
    returnEmpty: Boolean
    parent: String
    layer: Int!
  ): [InventoryCategoryType!]!
  getInventoryCategoriesByParent(parent: String!): [InventoryCategoryType!]!
  inventoryCategory(id: String!): InventoryCategoryType!
  searchInventoryCategory(
    layer: Int
    searchString: String
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): InventoryCategoryPaginateType!
  getCatalogueCategoriesByTargetPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
    target: TargetACIInput!
  ): CatalogueCategoryPaginateType!
  getCatalogueCategories(target: TargetACIInput!): [CatalogueCategoryType!]!
  getCatalogueCategoriesByTargetForPortal(
    target: TargetACIInput!
  ): [CatalogueCategoryType!]!
  getCatalogueCategoriesByLayerAndParentForPortal(
    parent: String
    target: TargetACIInput!
    layer: Int!
  ): [CatalogueCategoryType!]!
  getCatalogueCategoriesByLayerAndParent(
    parent: String
    variety: ProductVarietyEnum
    target: TargetACIInput!
    layer: Int!
  ): [CatalogueCategoryType!]!
  getCatalogueCategoriesByTargetAndUrlKey(
    urlKey: String
    target: TargetACIInput!
  ): CatalogueCategoryType!
  getCatalogueCategoryPath(id: ID!): [CatalogueCategoryType!]!
  catalogueCategory(id: ID!): CatalogueCategoryType!
  searchCatalogueCategories(
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
  ): CatalogueCategoryPaginateType!
  getCatalogueCategoriesByTargetWithChildren(
    target: TargetACIInput!
  ): [CatalogueCategoryWithChildrenType!]!
  findCatalogueCategoryByExternalIdAndTarget(
    target: TargetACIInput
    externalId: String!
  ): CatalogueCategoryType!
  getInternalProductBarcodes(id: String!): [BarcodeType!]!
  getInternalProductBarcodesPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
    id: String!
  ): BarcodePaginateType!
  getBarcodesWithVarietyAndStructureWithFilter(
    pagination: PaginationInput = { page: 0, limit: 20 }
    filter: BarcodeWithVarietyAndStructureFilterInput!
    target: TargetACIInput!
  ): BarcodePaginateType!
  getSimpleProductWithFavoriteStatus(
    # Internal product id
    id: ID!
  ): InternalProductWithFavoriteStatusType!
  getSimpleProductWithFavoriteStatusByUrlKey(
    # Internal product seo urlKey.
    urlKey: String!
    target: TargetACIInput!
  ): InternalProductWithFavoriteStatusType!
  getSimpleProductsByTargetAndCatalogueCategoryUrlKeyWithFavoriteStatus(
    pagination: PaginationInput = { page: 0, limit: 20 }
    target: TargetACIInput!
    urlKey: String!
  ): InternalProductWithFavoriteStatusPaginateType!
  getSimpleProductsByCatalogueCategoryWithFavoriteStatus(
    pagination: PaginationInput = { page: 0, limit: 20 }
    catalogueCategoryIds: [ID!]!
  ): InternalProductWithFavoriteStatusPaginateType!
  getSimpleBarcodeByBarcodeAndTarget(
    target: TargetACIInput!
    barcode: String!
  ): BarcodeType!
  getSimpleProductWithFilter(
    searchString: String
    pagination: PaginationInput = { page: 0, limit: 20 }
    filter: InternalProductFilterInput
    sort: [ProductSortInput!]
  ): InternalProductPaginateWithFilterType!
  searchSimpleEquipments(
    searchInput: SearchSimpleProductInput!
  ): InternalProductPaginateWithFilterType!
  searchSimpleServices(
    searchInput: SearchSimpleProductInput!
  ): BarcodePaginateType!
  getServiceProduct(target: TargetACIInput!): InternalProductType!
  searchSimpleBarcodesByTargetWithStock(
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
    target: TargetACIInput!
  ): BarcodeWithStockPaginatedType!
  getSimpleServicesWithFilter(
    searchString: String
    pagination: PaginationInput = { page: 0, limit: 20 }
    filter: BarcodesFilterInput
    sort: [ProductSortInput!]
    target: TargetACIInput!
  ): BarcodesPaginatedWithFilterType!
  getSimpleProductsWithRatingsWithFavoriteStatusWithFilter(
    searchString: String
    pagination: PaginationInput = { page: 0, limit: 20 }
    filter: InternalProductFilterInput
    sort: [ProductSortInput!]
  ): InternalProductWithRatingsPaginateWithFavoriteStatusWithFilterType!
  getSimpleBarcodesByBarcodesAndTarget(
    target: TargetACIInput!
    barcodes: [String!]!
  ): [BarcodeType!]!
  getSimpleProductsByTargetGroupedByClassWithFavoriteStatus(
    target: TargetACIInput!
  ): InternalProductByClassTypeWithFavoriteStatus!
  getInternalProducts(
    pagination: PaginationInput = { page: 0, limit: 20 }
    target: TargetACIInput
  ): InternalProductPaginateType!
  findInternalProductByExternalIdAndTarget(
    target: TargetACIInput
    externalId: String!
  ): InternalProductType!
  getAllInternalProducts(target: TargetACIInput): [InternalProductType!]!
  getAllInternalProductsByTargetGroupedByClass(
    target: TargetACIInput!
  ): InternalProductByClassType!
  getAllInternalProductsByTargetGroupedByClassWithFavoriteStatus(
    target: TargetACIInput!
  ): InternalProductByClassTypeWithFavoriteStatus!
  getInternalProductsByCategory(
    pagination: PaginationInput = { page: 0, limit: 20 }
    category: ID!
    target: TargetACIInput!
  ): InternalProductPaginateType!
  getInternalProductsByClass(
    pagination: PaginationInput = { page: 0, limit: 20 }
    class: [ProductClassEnum!]!
    target: TargetACIInput!
  ): InternalProductPaginateType!
  getInternalProductsByTargetAndCatalogueCategoryUrlKey(
    pagination: PaginationInput = { page: 0, limit: 20 }
    target: TargetACIInput!
    urlKey: String!
  ): InternalProductPaginateType!
  getInternalProductsByTargetAndCatalogueCategoryUrlKeyWithFavoriteStatus(
    pagination: PaginationInput = { page: 0, limit: 20 }
    target: TargetACIInput!
    urlKey: String!
  ): InternalProductWithFavoriteStatusPaginateType!
  getOneInternalProductByBarcodeAndTarget(
    target: TargetACIInput!
    barcode: ID!
  ): InternalProductType!
  getInternalProductsByTargetAndCatalogueCategory(
    pagination: PaginationInput = { page: 0, limit: 20 }
    target: TargetACIInput!
    category: ID!
  ): InternalProductPaginateType!
  getInternalProductsByCatalogueCategory(
    pagination: PaginationInput = { page: 0, limit: 20 }
    catalogueCategoryIds: [ID!]!
  ): InternalProductPaginateType!
  getInternalProductsByCatalogueCategoryWithFavoriteStatus(
    pagination: PaginationInput = { page: 0, limit: 20 }
    catalogueCategoryIds: [ID!]!
  ): InternalProductWithFavoriteStatusPaginateType!
  getInternalProductsByCatalogueCategoryForPortal(
    pagination: PaginationInput = { page: 0, limit: 20 }
    catalogueCategoryIds: [ID!]!
  ): InternalProductPaginateType!
  getInternalProductsByProduct(
    pagination: PaginationInput = { page: 0, limit: 20 }
    productId: ID!
  ): InternalProductPaginateType!
  getInternalProduct(id: ID!): InternalProductType!
  getInternalProductWithStock(id: ID!): InternalProductWithStockType!
  getInternalProductWithFavoriteStatus(
    id: ID!
  ): InternalProductWithFavoriteStatusType!
  searchInternalProduct(
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
  ): InternalProductPaginateType!
  searchInternalProductByCatalogueCategory(
    pagination: PaginationInput = { page: 0, limit: 20 }
    catalogueCategoryId: ID!
    searchString: String
  ): InternalProductPaginateType!
  searchInternalProductByTarget(
    pagination: PaginationInput = { page: 0, limit: 20 }
    target: TargetACIInput!
    searchString: String
  ): InternalProductPaginateType!
  searchBarcodesByTargetAndSupplier(
    pagination: PaginationInput = { page: 0, limit: 20 }
    target: TargetACIInput!
    supplier: ID!
    searchString: String
  ): BarcodePaginateType!
  getBarcodesByTargetPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
    target: TargetACIInput!
  ): BarcodePaginateType!
  getBarcodesByTargetWithInternalProductPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
    target: TargetACIInput!
    searchString: String
  ): BarcodePaginateType!
  getInternalProductWithFilter(
    searchString: String
    pagination: PaginationInput = { page: 0, limit: 20 }
    filter: InternalProductFilterInput
    sort: [ProductSortInput!]
  ): InternalProductPaginateWithFilterType!
  getInternalProductsWithRatingsWithFilter(
    searchString: String
    pagination: PaginationInput = { page: 0, limit: 20 }
    filter: InternalProductFilterInput
    sort: [ProductSortInput!]
  ): InternalProductWithRatingsPaginateWithFilterType!
  getInternalProductsWithRatingsWithFavoriteStatusWithFilter(
    searchString: String
    pagination: PaginationInput = { page: 0, limit: 20 }
    filter: InternalProductFilterInput
    sort: [ProductSortInput!]
  ): InternalProductWithRatingsPaginateWithFavoriteStatusWithFilterType!
  getBarcodeByBarcodeAndTarget(
    target: TargetACIInput!
    barcode: String!
  ): BarcodeType!
  getBarcodesByBarcodesAndTarget(
    target: TargetACIInput!
    barcodes: [String!]!
  ): [BarcodeType!]!
  getBarcodesWithFilter(
    pagination: PaginationInput = { page: 0, limit: 20 }
    filter: BarcodeFilterInput!
    target: TargetACIInput!
  ): BarcodePaginateType!
  searchBarcodesByTarget(
    pagination: PaginationInput = { page: 0, limit: 20 }
    target: TargetACIInput!
    searchString: String
  ): BarcodePaginateType!
  searchBarcodesByTargetWithStock(
    pagination: PaginationInput = { page: 0, limit: 20 }
    target: TargetACIInput!
    searchString: String
  ): BarcodeWithStockPaginatedType!
  getModuleDefinitions: [ModulesDefinitionType!]!
  moduleDefinition(id: String!): ModulesDefinitionType!
  findModuleDefinitionsByTarget(
    target: TargetTypeEnum!
  ): [ModulesDefinitionType!]!
  sendSms(
    time: String!
    date: String!
    smsContent: String!
    phoneNumber: String!
  ): SmsIntegrationType!
  validateRegisterPhoneNumber(smsNumber: Int!, phone: IPhoneInput!): SmsLogType!
  getCompanyContacts: [CompanyContactType!]!
  companyContact(id: ID!): CompanyContactType!
  getCompanyContactsByCompany(company: ID!): [CompanyContactType!]!
  getCompanyContactsByCompanyPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
    company: ID!
  ): CompanyContactPaginateType!
  getCompanyContactsByTargetPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
    phase: CustomerPhaseEnum!
    target: TargetACIInput!
  ): CompanyContactPaginateType!
  validateCatalogueByExcel(
    path: String
    base64: String
  ): CatalogueImportValidationType!
  getPosTemplateByExcel(path: String): InvoicePDFType!
  sendPosTemplateBymail(emails: [String!], subject: String!): MailResponseDto!
  getCatalogueTemplateByExcel(path: String): InvoicePDFType!
  sendCatalogueTemplateBymail(
    emails: [String!]
    subject: String!
  ): MailResponseDto!
  getServicesCatalogueTemplateByExcel(path: String): InvoicePDFType!
  sendServicesCatalogueTemplateBymail(
    emails: [String!]
    subject: String!
  ): MailResponseDto!
  getFullCatalogueByExcel(
    path: String
    withStock: Boolean!
    target: TargetACIInput!
  ): InvoicePDFType!
  sendFullCatalogueBymail(
    subject: String!
    emails: [String!]
    withStock: Boolean!
    target: TargetACIInput
  ): MailResponseDto!
  getCustomersTemplateByExcel(path: String): InvoicePDFType!
  getSuppliersTemplateByExcel(path: String): InvoicePDFType!
  getModulesAssignment: [ModulesAssignmentType!]!
  moduleAssignment(id: String!): ModulesAssignmentType!
  getModuleAssignmentsByAssignee(
    assignee: AssigneeInput!
  ): [ModulesAssignmentType!]!
  findModuleAssignmentsByOrigin: [ModulesAssignmentType!]!
  findModuleAssignmentsforFrame(posId: String!): [ModulesAssignmentType!]!
  generateCloudinarySignature(
    public_id: String
    folder: String!
  ): CloudinarySignatureType!
  getImagesFromFolder(path: String!): [CloudinaryResourceType!]!
  getGuidanceTypes: StringListType!
  getCurrencies: StringListType!
  getApps: StringListType!
  getBrandColors: [KeyValueListType!]!
  getOrderStatuses: StringListType!
  getDiscountTypes: StringListType!
  getChatContacts: StringListType!
  getSocialMedias: StringListType!
  uploadImage(remotePath: String!, localPath: String!): PictureType!
  getFormsPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): FormPaginateType!
  getForms: [FormResponseType!]!
  form(id: String!): FormResponseType!
  searchForms(
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
  ): FormPaginateType!
  getFormsWithFilters(
    pagination: PaginationInput = { page: 0, limit: 20 }
    input: FormFiltersInput!
  ): FormPaginateType!
  getResponsesPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): ResponsePaginateType!
  getResponses: [ResponseDtoType!]!
  response(id: String!): ResponseDtoType!
  searchResponse(
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
  ): ResponsePaginateType!
  getResponsesWithFilter(
    pagination: PaginationInput = { page: 0, limit: 20 }
    input: ResponseFilterInput!
  ): ResponsePaginateType!
  getSummary(formId: String!): [SummaryResponseDtoType!]!
  getQuestionResponses(
    pagination: PaginationInput = { page: 0, limit: 20 }
    questionId: String!
  ): GetQuestionResponsesPaginateType!
  exportResponsesByMail(
    input: ResponseFilterInput!
    subject: String!
    email: String!
  ): MailResponseDto!
  getAuthDashboardData(
    apps: [App!]
    to: DateTime
    from: DateTime
  ): AuthDashboardType!
  getAuthDashboardDataByApp(
    to: DateTime
    from: DateTime
  ): AuthDashboardByAppType!
  getCockpitDashboardPreviewByApp: AuthDashboardPreviewByAppType!
  getCockpitDashboardAnalyticsByApp: GetCockPitDashboardAnalyticsByAppType!
  getCockpitDashboardUsersAnalyticsByApp(
    to: DateTime!
    from: DateTime!
  ): GetCockPitDashboardUserAnalyticsByAppType!
  getCockpitDashboardSessionsAnalyticsByApp(
    to: DateTime!
    from: DateTime!
  ): [DurationsCountType!]!
  getCorporateDashboardData: CorporateDashboardType!
  getCorporateTargetDashboardData(
    target: TargetACIInput!
  ): CorporateTargetDashboardType!
  getCorporateUserAnalytics(
    to: DateTime!
    from: DateTime!
    target: TargetACIInput!
  ): GetCorporateUserAnalyticsType!
  getCorporateUserByDayInPeriodAnalytics(
    to: DateTime!
    from: DateTime!
    target: TargetACIInput!
  ): GetCorporateUserByDayInPeriodAnalyticsType!
  getCorporateUsersRequestsAnalytics(
    to: DateTime!
    from: DateTime!
    target: TargetACIInput!
  ): GetCorporateUsersRequestsAnalyticsType!
  getCorporateUsersDashboardData(
    to: DateTime!
    from: DateTime!
    target: TargetACIInput!
  ): CorporateUserDashboardType!
  getCorporateUsersTechnologiesDashboardData(
    to: DateTime!
    from: DateTime!
    target: TargetACIInput!
  ): GetCorporateUsersTechnologiesDashboardDataType!
  getCorporateWarehouseDashboardData(
    to: DateTime!
    from: DateTime!
    target: TargetACIInput!
  ): GetCorporateWarehouseDashboardDataType!
  getInventoryDashboardData: InventoryDashboardType!
  getOrder(id: String!): OrderType!
  getOrderByNumber(orderNumber: Float!): OrderType!
  findOrdersByPOS(
    pagination: PaginationInput = { page: 0, limit: 20 }
    input: OrderPOSFilterInput!
  ): OrderPaginateType!
  exportPOSOrdersWithFilter(input: OrderPOSFilterInput!): DocumentResultType!
  exportPOSOrdersWithFilterByMail(
    input: OrderPOSFilterInput!
    emails: [String!]!
  ): MailResponseDto!
  exportOrdersWithFilter(
    target: OwnerOrTargetInput
    input: OrderFilterInput!
  ): DocumentResultType!
  exportOrdersWithFilterByMail(
    target: OwnerOrTargetInput
    emails: [String!]!
    input: OrderFilterInput!
  ): MailResponseDto!
  createPDFAdhocInvoice(app: App!, orderId: String!): InvoicePDFType!
  sendPDFAdhocInvoiceBymail(
    app: App!
    orderId: String!
    emails: [String!]!
  ): MailResponseDto!
  findOrdersByUser(
    input: OrderFilterNoUserInput!
    pagination: PaginationInput = { page: 0, limit: 20 }
    target: OwnerOrTargetInput!
  ): OrderPaginateType!
  getOrdersByTargetWithFilter(
    pagination: PaginationInput = { page: 0, limit: 20 }
    input: OrderFilterInput!
    target: OwnerOrTargetInput!
  ): OrderPaginateType!
  getLastOrdersOfPos(
    target: OwnerOrTargetInput!
    count: Float!
    pos: String!
  ): [OrderType!]!
  getVisitsStats(
    target: TargetACIInput!

    # List of Point of sales ids.
    POSes: [ID!]

    # List of Commercials users ids.
    commercials: [ID!]
    from: DateTime!
    to: DateTime!
  ): GetVisitsStatsResponseType!
  getOrdersStatsWithFilter(
    target: TargetACIInput!

    # List of Point of sales ids.
    POSes: [ID!]

    # List of Commercials users ids.
    commercials: [ID!]
    from: DateTime!
    to: DateTime!
  ): GetOrdersStatsWithFilterResponseType!
  getOrdersRevenueStatsWithFilter(
    target: TargetACIInput!

    # List of Point of sales ids.
    POSes: [ID!]

    # List of Commercials users ids.
    commercials: [ID!]
    from: DateTime!
    to: DateTime!
  ): GetOrdersRevenueStatsWithFilterResponseType!
  getOrdersCountByStatusWithFilter(
    target: TargetACIInput!

    # List of Point of sales ids.
    POSes: [ID!]

    # List of Commercials users ids.
    commercials: [ID!]
    from: DateTime!
    to: DateTime!
  ): GetOrdersCountByStatusWithFilterResponseType!
  getCreditsStatsWithFilter(
    target: TargetACIInput!

    # List of Point of sales ids.
    POSes: [ID!]

    # List of Commercials users ids.
    commercials: [ID!]
    from: DateTime!
    to: DateTime!
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): PointOfSaleWithInstallmentsPaginateType!
  getProductsStatsWithFilter(
    target: TargetACIInput!

    # List of Point of sales ids.
    POSes: [ID!]

    # List of Commercials users ids.
    commercials: [ID!]
    from: DateTime!
    to: DateTime!

    # List of catalogue categories ids.
    categories: [ID!]

    # group not selected categories into a single group.
    groupOthers: Boolean

    # Top products count (defaults to 5).
    count: Int = 5
  ): GetProductsStatsWithFilterResponseType!
  getLastBestSellerOfPos(
    target: OwnerOrTargetInput!
    count: Float!
    pos: String!
  ): [OrderProductType!]!
  getSalesTotal(input: DashboardSalesFilterInput!): TotalAmountType!
  getTopProducts(
    input: DashboardTopProductsFilterInput!
  ): [InternalProductWithQuantityType!]!
  getPOSBundlePagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): POSBundlePaginateType!
  posBundle(id: String!): POSBundleType!
  isPosAssignedToPOSBundleOwner(
    owner: OwnerOrTargetInput!
    posId: String!
  ): IsPosAssignedToOwnerType!
  getPOSBundleByOwner(
    pagination: PaginationInput = { page: 0, limit: 20 }
    owner: OwnerOrTargetInput!
  ): POSBundlePaginateType!
  getDistributionNetworkPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): DistributionNetworkPaginateType!
  distributionNetwork(id: ID!): DistributionNetworkType!
  getDistributionNetworkOwners(
    pagination: PaginationInput = { page: 0, limit: 20 }
    posId: ID!
  ): DistributionNetworkOwnersPaginateType!
  isPosAssignedToDistributionNetworkOwner(
    owner: DistributionNetworkOwnerInput!
    posId: ID!
  ): IsPosAssignedToOwnerType!
  getDistributionNetworkByOwner(
    owner: DistributionNetworkOwnerInput!
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): DistributionNetworkTargetPaginateType!
  getDistributionNetworkUsers(
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String!
    owner: DistributionNetworkOwnerInput!
  ): UserPaginateType!
  getNearByDistributionNetworksByOwner(
    pagination: PaginationInput = { page: 0, limit: 20 }
    owner: DistributionNetworkOwnerInput!
    rad: Float!
    lat: Float!
    lon: Float!
  ): PointOfSaleWithReferencePaginateType!
  searchDistributionNetworksByOwner(
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String!
    owner: DistributionNetworkOwnerInput!
  ): PointOfSaleWithReferencePaginateType!
  searchNearByDistributionNetworksByOwner(
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String!
    owner: DistributionNetworkOwnerInput!
    rad: Float!
    lat: Float!
    lon: Float!
  ): PointOfSaleWithReferencePaginateType!
  getChechinActivitiesPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): CheckinActivityPaginateType!
  checkinActivity(id: ID!): CheckinActivityType!
  getCurrentUserCheckins(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): CheckinActivityPaginateType!
  findCheckinActivitiesWithFilter(
    input: CheckinActivityFilterInput!
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): CheckinActivityPaginateType!
  findCheckinActivitiesWithFilterWithStats(
    input: CheckinActivityFilterInput!
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): PaginatedCheckinActivityWithStatsType!
  exportCheckinActivities(
    input: CheckinActivityFilterInput!
  ): DocumentResultType!
  exportCheckinActivitiesByMail(
    input: CheckinActivityFilterInput!
    emails: [String!]!
  ): MailResponseDto!
  getIntegrationSettingsPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): IntegrationSettingsPaginateType!
  integrationSetting(id: String!): IntegrationSettingsType!
  getIntegrationSettingByTarget(
    target: OwnerOrTargetInput!
  ): IntegrationSettingsType!
  getChargeDischargePagination(
    target: OwnerOrTargetInput!
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): ChargeDischargePaginateType!
  getChargeDischarge(id: ID!): ChargeDischargeType!
  getChargeDischargeWithFilter(
    target: OwnerOrTargetInput!
    pagination: PaginationInput = { page: 0, limit: 20 }
    input: ChargeDischargeFilterInput!
  ): ChargeDischargeWithInternalProductsPaginateType!
  getChargeDischargeByExcel(
    path: String
    target: OwnerOrTargetInput!
    input: ChargeDischargeFilterInput!
  ): InvoicePDFType!
  getOneChargeDischargeByExcel(path: String, id: ID!): InvoicePDFType!
  getCalendars: [CalendarType!]!
  calendar(id: ID!): CalendarType!
  getCalendarsPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): PaginatedCalendarsType!
  findCalendarsByTarget(target: TargetACIInput!): [CalendarType!]!
  findCalendarsByUserAndTarget(
    target: TargetACIInput!
    userId: ID!
  ): [CalendarType!]!
  findCalendarsByTargetPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
    target: TargetACIInput!
  ): PaginatedCalendarsType!
  getTeamSettings: [TeamSettingsType!]!
  teamSettings(id: ID!): TeamSettingsType!
  getTeamSettingsPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): PaginatedTeamSettingsType!
  findTeamSettingsByTarget(target: TargetACIInput!): [TeamSettingsType!]!
  findTeamSettingsByUserAndTarget(
    target: TargetACIInput!
    userId: ID!
  ): [TeamSettingsType!]!
  findTeamSettingsByTargetPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
    target: TargetACIInput!
  ): PaginatedTeamSettingsType!
  getStocks: [StockType!]!
  getStock(
    target: TargetACIInput!

    # barcodeId only provided if barcode is not.
    barcodeId: ID

    # barcode value only provided if barcodeId is not.
    barcode: String
    warehouse: ID
  ): StockType!
  getStockByTargetAndBarcode(
    target: TargetACIInput!
    barcode: String!
  ): StockType!
  getStocksByTarget(
    outOfStock: Boolean
    pagination: PaginationInput = { page: 0, limit: 20 }
    target: TargetACIInput!
  ): StockPaginateType!
  getStocksByTargetInAllWarehouses(
    outOfStock: Boolean
    pagination: PaginationInput = { page: 0, limit: 20 }
    target: TargetACIInput!
  ): BarcodeWithStockDataPaginatedType!
  searchStocksByTarget(
    searchString: String
    target: TargetACIInput!

    # The field to sort the result by (default updatedAt).
    sortingField: String = "updatedAt"

    # The sorting order of the result 1 for ascending and -1 for descending by (default -1 => descending).
    sortingOrder: Float = -1

    # search in out of stock products if true and in instock products if false, in both if not passed.
    outOfStock: Boolean
    pagination: PaginationInput = { page: 0, limit: 20 }
    warehouse: ID
  ): StockPaginateType!
  searchSimpleStocksByTarget(
    searchString: String
    target: TargetACIInput!

    # The field to sort the result by (default updatedAt).
    sortingField: String = "updatedAt"

    # The sorting order of the result 1 for ascending and -1 for descending by (default -1 => descending).
    sortingOrder: Float = -1

    # search in out of stock products if true and in instock products if false, in both if not passed.
    outOfStock: Boolean
    pagination: PaginationInput = { page: 0, limit: 20 }
    warehouse: ID
  ): StockPaginateType!
  getProductRatings(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): ProductRatingPaginateType!
  getAllProductRatings: [ProductRatingType!]!
  getProductRatingsByProduct(
    pagination: PaginationInput = { page: 0, limit: 20 }

    # The product id.
    productId: ID!
  ): ProductRatingPaginateType!
  getProductRatingsByProductWithStats(
    pagination: PaginationInput = { page: 0, limit: 20 }

    # The product id.
    productId: ID!
  ): ProductRatingWithStatsPaginatedType!
  getAverageProductRatingsByProduct(
    # The product id.
    productId: ID!
  ): AverageRatingType!
  productRating(
    # The product id.
    id: ID!
  ): ProductRatingType!
  getWalletsPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): WalletPaginateType!
  wallet(id: String!): WalletDtoType!
  walletByOwner(
    pos: ID
    user: ID
    wholesaler: ID
    manufacturer: ID
  ): WalletDtoType!
  isWalletAndCardInitialized(
    userId: String
  ): IsWalletAndCardInititalizedDtoType!
  getCurrentUserQuantitativeWallet: WalletOnePocketDtoType!
  getCurrentUserQualitativeWallet(
    target: TargetACIInput!
  ): WalletOnePocketDtoType!
  getTargetWallet(target: TargetACIInput!): WalletDtoType!
  getPointOfSalesWithWalletsForModule(
    searchString: String
    pagination: PaginationInput = { page: 0, limit: 20 }
    moduleName: String!
  ): POSWithWalletPaginateType!
  walletOwnerHasEnoughBalance(
    pos: ID
    user: ID
    wholesaler: ID
    manufacturer: ID
    amount: Float!
    usage: PocketUsageType!
  ): WalletOwnerHasEnoughBalanceType!
  getOnsiteConverters: [OnsiteConverterType!]!
  getOnsiteConverterByTarget(target: TargetACIInput!): OnsiteConverterType!
  getOnsiteConverterAmount(
    target: TargetACIInput!
    reputationLevelId: String!
    amount: Float!
  ): RemunerationAmountType!
  findLoyaltySettingsByTarget(target: TargetACIInput!): LoyaltySettingsType!
  getReputationsPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): ReputationPaginateType!
  getReputations: [ReputationType!]!
  getReputationsByTarget(target: TargetACIInput!): [ReputationType!]!
  reputation(id: String!): ReputationType!
  getUserWalletWithReputations: WalletWithReputationDtoType!
  getTargetSubscribersPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
    target: TargetACIInput!
    status: [SubscriptionStatus!]!
  ): SubscribersWithReputationsPaginateType!
  searchTargetSubscribers(
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
    target: TargetACIInput!
    statuses: [SubscriptionStatus!]
  ): SubscribersWithReputationsPaginateType!
  getTargetSubscribersByExcel(
    path: String
    searchString: String
    statuses: [SubscriptionStatus!]
    target: TargetACIInput!
  ): InvoicePDFType!
  sendTargetSubscribersBymail(
    subject: String!
    emails: [String!]
    searchString: String
    statuses: [SubscriptionStatus!]
    target: TargetACIInput
  ): MailResponseDto!
  searchUserTargetSubscriptions(
    statuses: [SubscriptionStatus!]
    target: TargetACIInput!
    searchString: String
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): TargetPaginateType!
  getUserSubscribedTargets(
    statuses: [SubscriptionStatus!]
    userId: String
  ): [TargetType!]!
  getTargetStats(target: TargetACIInput!): StatsType!
  isUserSubscribedToTarget(
    target: TargetACIInput!
  ): IsUserSubscribedToTargetType!
  getCorporateUserCards: [CorporateUserCardType!]!
  corporateUserCard(id: ID!): CorporateUserCardType!
  findCurrentCorporateUserCards: [CorporateUserCardType!]!
  findCurrentCorporateUserCardsByTarget(
    target: TargetACIInput!
  ): [CorporateUserCardType!]!
  corporateUserCardByIdentifier(identifier: String!): CorporateUserCardType!
  getCorporateUserCardsByUser(userId: ID!): [CorporateUserCardType!]!
  getCorporateUserCardsByTarget(
    target: TargetACIInput!
  ): [CorporateUserCardType!]!
  getCorporateUserCardsByTargetPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
    cardType: CardTypeEnum
    target: TargetACIInput!
  ): CorporateUserCardFullPaginatedType!
  getCorporateUserCardByUserAndTarget(
    target: TargetACIInput!
    userId: ID!
  ): [CorporateUserCardType!]!
  getTargetFollowersPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): FollowerPaginateType!
  getFollowedTargetsByUser(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): FollowerPaginateType!
  getFollowersWithFilter(
    pagination: PaginationInput = { page: 0, limit: 20 }
    input: FollowerFilterInput!
  ): FollowerPaginateType!
  getFollowersByTargetPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
    target: TargetACIInput!
  ): FollowerPaginateType!
  isTargetFollowedByUser(target: TargetACIInput!): IsFollowedType!
  searchFollowers(
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
  ): FollowerPaginateType!
  searchFollowedTargetsByUser(
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
  ): FollowerPaginateType!
  getActivityLogs: [ActivityLogType!]!
  ActivityLog(id: String!): ActivityLogType!
  getPosTransactions(
    pagination: PaginationInput = { page: 0, limit: 20 }
    activityType: [ActivityLogTypeEnum!]
    posId: String!
  ): ActivityLogPaginateType!
  getTargetTransactions(
    pagination: PaginationInput = { page: 0, limit: 20 }
    activityType: [ActivityLogTypeEnum!]
    searchString: String
    target: TargetACIInput!
  ): ActivityLogPaginateType!
  getTargetTransactionsByExcel(
    path: String
    activityType: [ActivityLogTypeEnum!]
    searchString: String
    target: TargetACIInput!
  ): InvoicePDFType!
  sendTargetTransactionsBymail(
    activityType: [ActivityLogTypeEnum!]
    subject: String!
    emails: [String!]
    searchString: String
    target: TargetACIInput
  ): MailResponseDto!
  getActivityLogsPagination(
    status: [ActivityLogTypeEnum!]
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): ActivityLogPaginateType!
  countUnseenNotificationsByPOS(posId: String!): UnseenNotificationCountType!
  countUnseenNotificationsByUser: UnseenNotificationCountType!
  sendAdhocNotificationTest(
    picture: PictureInput!
    description: String!
    userId: String!
    title: String!
  ): AdhocNotificationTestType!
  sendUserAdhocNotification(
    executedAt: DateTime
    picture: PictureInput!
    description: String!
    userId: String!
    title: String!
  ): AdhocNotificationTestType!
  sendAdhocNotificationToTopicTest(
    picture: PictureInput!
    description: String!
    topic: String!
    title: String!
  ): AdhocNotificationTestType!
  findCounteryById(id: ID!): CountryType!
  getCountries: [CountryType!]!
  findCountriesPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): CountryPaginatedType!
  findStateById(id: ID!): StateType!
  getStates: [StateType!]!
  findStatesPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): StatePaginatedType!
  findStatesByCountryPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
    country: ID!
  ): StatePaginatedType!
  findLanguageById(id: ID!): LanguageType!
  getLanguages: [LanguageType!]!
  findlanguagesPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): LanguagePaginatedType!
  findSocialById(id: ID!): SocialType!
  findSocialByCode(code: String!): SocialType!
  findSocialsPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): SocialPaginatedType!
  findPaymentById(id: ID!): PaymentType!
  findPaymentsPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): PaymentPaginatedType!
  findPayments: [PaymentType!]!
  findBrowserById(id: ID!): BrowserType!
  findBrowsersPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): BrowserPaginatedType!
  findTechDeviceById(id: ID!): TechDeviceType!
  findTechDevicesPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): TechDevicePaginatedType!
  findTechDeviceBrandById(id: ID!): TechDeviceBrandType!
  findTechDeviceBrandsPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): TechDeviceBrandPaginatedType!
  findDeviceTypeById(id: ID!): TechDeviceTypeType!
  findDeviceTypesPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): TechDeviceTypePaginatedType!
  findOperatingSystemById(id: ID!): OperatingSystemType!
  findOperatingSystemsPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): OperatingSystemPaginatedType!
  findBankById(id: ID!): BankType!
  getBanks: [BankType!]!
  findBanksPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): BankPaginatedType!
  findBankDetailsById(id: ID!): BankDetailsType!
  findBanksDetailsPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): BankDetailsPaginatedType!
  sendEmail(input: EmailTempInput!): MailResponseDto!
  getEmailTemplate: [EmailTemplateType!]!
  emailTemplate(id: ID!): EmailTemplateType!
  findEmailTemplateByName(name: EmailTemplateTypeEnum!): EmailTemplateType!
  getWeatherPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): WeatherPaginateType!
  weather(id: ID!): WeatherType!
  findLatestCurrentWeather: WeatherWithIconType!
  getWeatherIconsPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): WeatherIconsPaginateType!
  weatherIcons(id: ID!): WeatherIconsType!
  weatherIconsByCode(code: Int!): WeatherIconsType!
  getPosAttributess: [PosAttributesType!]!
  getPosAttributessPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): PaginatedPosAttributesType!
  posAttributes(id: String!): PosAttributesType!
  posAttributesByPos(pos: ID!): PosAttributesType!
  getVisibilityClassifications: [VisibilityClassificationType!]!
  getVisibilityClassificationsPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): PaginatedVisibilityClassificationType!
  visibilityClassification(id: String!): VisibilityClassificationType!
  getVisibilityClassificationsBySectionPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
    section: String!
  ): PaginatedVisibilityClassificationType!
  getVisibilityItems: [VisibilityItemType!]!
  getVisibilityItemsPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): PaginatedVisibilityItemType!
  visibilityItem(id: String!): VisibilityItemType!
  getVisibilityItemsByClassificationPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
    classification: ID!
  ): PaginatedVisibilityItemType!
  getVisibilitySections: [VisibilitySectionType!]!
  getVisibilitySectionsbyTargetPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
    owner: VisibilityOwnerEnum!
    target: TargetACIInput!
  ): PaginatedVisibilitySectionType!
  getVisibilitySectionsPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): PaginatedVisibilitySectionType!
  visibilitySection(id: String!): VisibilitySectionType!
  getPosVisibilities: [PosVisibilityType!]!
  getPosVisibilitiesPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): PaginatedPosVisibilityType!
  posVisibility(id: String!): PosVisibilityType!
  getPosVisibilityByPosAndTarget(
    pagination: PaginationInput = { page: 0, limit: 20 }
    target: TargetACIInput!
    pos: ID!
  ): PaginatedPosVisibilityType!
  getMerchDataTypeByTargetPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
    target: TargetACIInput!
  ): PaginatedMerchDataTypeType!
  merchDataType(id: String!): MerchDataTypeType!
  getMerchDataPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): PaginatedMerchDataType!
  getMerchDataFilterPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
    value: Float!
    type: String!
  ): PaginatedMerchDataType!
  getMerchData: [MerchDataType!]!
  MerchData(id: String!): MerchDataType!
}

input LoginInput {
  # Login email or username.
  login: String
  phone: IPhoneInput
  password: String!
}

input IPhoneInput {
  # Phone number
  number: String

  # Phone country code
  countryCode: String
}

input AuthorizationDataInput {
  email: String
  state: String
  givenName: String
  familyName: String
  identityToken: String!
  userIdentifier: String
  authorizationCode: String
}

input PaginationInput {
  page: Int = 0
  limit: Int = 20
}

input IsLoginExistInput {
  # Login email or username.
  login: String
  phone: IPhoneInput
}

input TargetACIInput {
  # pos id
  pos: String

  # wholesaler id
  wholesaler: String

  # manufacturer id
  manufacturer: String

  # Commercial id
  user: String
}

input ProductSortInput {
  # 1 for sort by createdAt ascending and -1 for descending
  createdAt: Float

  # 1 for sort by updatedAt ascending and -1 for descending
  updatedAt: Float

  # 1 for sort by name ascending and -1 for descending
  name: Float

  # 1 for sort by price ascending and -1 for descending
  price: Float
}

input ProductFilterInput {
  fromPrice: String
  toPrice: String
  from: DateTime
  to: DateTime

  # list of productAttributes ids
  productAttributes: [String!]

  # list of barcodes ids
  barcodes: [ID!]

  # list of brands ids
  brand: [String!]

  # list of inventoryCategories ids
  category: [String!]
  class: [ProductClassEnum!]
  structure: [ProductStructureEnum!]
  variety: [ProductVarietyEnum!]
  rent: Boolean
}

input BarcodeFindInput {
  product: ID
  internalProduct: ID
  productAttributesValues: [ID!]
}

input OwnerOrTargetInput {
  wholesaler: ID
  manufacturer: ID
}

input LocationFilterInput {
  locationType: [LocationTypeEnum!]
  from: DateTime
  to: DateTime
}

input BarcodeWithVarietyAndStructureFilterInput {
  barcode: [String!]
  status: [ProductStatusEnum!]
  condition: [ProductConditionEnum!]
  structure: [ProductStructureEnum!]
  variety: [ProductVarietyEnum!]
  searchString: String
}

input InternalProductFilterInput {
  fromPrice: String
  toPrice: String
  from: DateTime
  to: DateTime

  # list of brands ids
  brand: [ID!]

  # list of inventoryCategories ids
  category: [ID!]
  target: TargetsInput
  attributesValues: [ID!]

  # list of catalogueCategories ids
  catalogueCategory: [ID!]

  # list of internalProduct classes
  class: [ProductClassEnum!]
  condition: [ProductConditionEnum!]
  status: [ProductStatusEnum!]
  structure: [ProductStructureEnum!]
  variety: [ProductVarietyEnum!]
  rent: Boolean
}

input TargetsInput {
  # list of pointOfSales ids
  pos: [ID!]

  # list of wholesalers ids
  wholesaler: [ID!]

  # list of manufacturers ids
  manufacturer: [ID!]
}

input SearchSimpleProductInput {
  target: TargetACIInput
  searchString: String
  status: [ProductStatusEnum!]
  pagination: PaginationInput = { page: 0, limit: 20 }
}

input BarcodesFilterInput {
  fromPrice: String
  toPrice: String
  from: DateTime
  to: DateTime

  # list of catalogueCategories ids
  catalogueCategory: [ID!]
}

input BarcodeFilterInput {
  barcode: [String!]
  status: [ProductStatusEnum!]
  condition: [ProductConditionEnum!]
}

input AssigneeInput {
  user: String
  pos: String
  wholesaler: String
  manufacturer: String
}

input FormFiltersInput {
  owner: FormOwnerFilterInput
  questions: [String!]
  types: [FormType!]
  statuses: [FormStatus!]
}

input FormOwnerFilterInput {
  pos: [String!]
  wholesaler: [String!]
  manufacturers: [String!]
}

input ResponseFilterInput {
  to: DateTime
  from: DateTime
  pos: [String!]
  users: [String!]
  forms: [String!]
  executors: [String!]
}

input OrderPOSFilterInput {
  status: [OrderStatus!]
  orderType: [OrderTypeEnum!]
  from: DateTime
  to: DateTime
  pos: String!
  orderStatus: [OrderStatus!]
  paymentStatus: [PaymentStatusEnum!]
}

input OrderFilterInput {
  orderNumber: [Float!]
  status: [OrderStatus!]
  orderType: [OrderTypeEnum!]
  from: DateTime
  to: DateTime
  user: [String!]
}

input OrderFilterNoUserInput {
  orderNumber: [Float!]
  status: [OrderStatus!]
  orderType: [OrderTypeEnum!]
  from: DateTime
  to: DateTime
}

input DashboardSalesFilterInput {
  to: DateTime
  from: DateTime
  merchandisers: [String!]
  targets: OwnersOrTargestInput!
}

input OwnersOrTargestInput {
  wholesalers: [ID!]
  manufacturers: [ID!]
}

input DashboardTopProductsFilterInput {
  to: DateTime
  from: DateTime
  merchandisers: [String!]
  targets: OwnersOrTargestInput!
  count: Int = 10
}

input DistributionNetworkOwnerInput {
  wholesaler: ID
  manufacturer: ID
  user: ID
}

input CheckinActivityFilterInput {
  user: [String!]
  pos: [String!]
  checkinTypes: [CheckinTypeEnum!]
  from: DateTime
  to: DateTime
  owners: CheckinActivityOwnersInput!
}

input CheckinActivityOwnersInput {
  wholesaler: [String!]
  manufacturer: [String!]
}

input ChargeDischargeFilterInput {
  to: DateTime
  from: DateTime
  user: [String!]
  executor: [String!]
  chargeType: [ChargeDischargeEnum!]
}

input FollowerFilterInput {
  user: [String!]
  pos: [Float!]
  from: DateTime
  to: DateTime
}

input PictureInput {
  width: Int
  height: Int
  x: Int
  y: Int
  alt: String
  baseUrl: String!
  path: String!
}

input EmailTempInput {
  to: [String!]!
  subject: String!
  template: EmailTemplateTypeEnum
  content: EmailContentInput
  variables: EmailTempVariablesInput
  attachments: [MailAttachmentInput!]
}

input EmailContentInput {
  base64: String
  path: String
}

input EmailTempVariablesInput {
  brand: EmailTempVariablesBrandInput
  user: EmailTempVariablesUserInput
  company: EmailTempVariablesCompanyInput
  actionUrl: String
  document: EmailTempVariablesDocumentInput
  variables: [String!]
}

input EmailTempVariablesBrandInput {
  logo: String
  website: String
  name: String
}

input EmailTempVariablesUserInput {
  firstName: String
  lastName: String
  email: String
}

input EmailTempVariablesCompanyInput {
  name: String
  website: String
  phone: String
  address: String
}

input EmailTempVariablesDocumentInput {
  category: SequenceCategoryEnum
  id: ID
  name: String
  document: InvoicingInput
  receiver: ID
}

enum SequenceCategoryEnum {
  QUOTATION
  SALE_ORDER
  SALE_INVOICE
  SALE_DELIVERY_NOTE
  SALE_ISSUE_NOTE
  PURCHASE_INVOICE
  PURCHASE_DELIVERY_NOTE
  PURCHASE_ORDER
}

input InvoicingInput {
  number: String
  date: DateTime
  note: String
  details: [KeyValueInput!]
  products: [InvoicingProductsBundleInput!]!
  status: GenericInvoicingStatusEnum
  address: InvoicingAddressInput
  taxes: [taxRankInput!]
  installments: [InstallmentInput!]
  discount: DiscountDtoInput
  logistic: ID
  project: ID
  target: TargetACIInput!
  company: ID!
  totalPrice: TotalPriceInput
  toPay: String
  totalTax: String
  totalReductions: String
  bank: ID
}

input KeyValueInput {
  key: String
  value: String
}

input InvoicingProductsBundleInput {
  product: InvoicingProductsInput
  text: String
  value: String
  rank: Int!
  kind: ProductKindEnum!
}

input InvoicingProductsInput {
  article: ID!
  label: String!
  description: String
  price: String!
  total: String!
  taxes: [ProductTaxesInput!]!
  quantity: Int!
  discount: DiscountDtoInput
  rent: RentalRefInput
}

input ProductTaxesInput {
  tax: ID!
  rank: Int!
}

input DiscountDtoInput {
  discountType: DiscountType!
  amount: String
}

input RentalRefInput {
  location: String
  description: String
  status: RentalStatusEnum
  start: DateTime
  end: DateTime
  note: RentalNoteInput
}

input RentalNoteInput {
  return: String
  delivery: String
}

input InvoicingAddressInput {
  billing: FullAddressInput
  shipping: FullAddressInput
}

input FullAddressInput {
  owner: FullAddressOwnerInput
  address: String
  postCode: String
  city: String
  country: ID
  state: ID
  addressLine: String
  location: LonLatInput
}

input FullAddressOwnerInput {
  name: String
  phone: FullAddressOwnerPhoneInput
}

input FullAddressOwnerPhoneInput {
  number: String
  countryCode: String
}

input LonLatInput {
  type: String!
  coordinates: [Float!]!
}

input taxRankInput {
  tax: ID!
  rank: Int!
}

input InstallmentInput {
  amount: String!
  paymentMethod: String!
  paymentStatus: PaymentStatusEnum!
  paidAt: DateTime
  deadline: DateTime
}

input TotalPriceInput {
  net: String
  gross: String
}

input MailAttachmentInput {
  filename: String!
  content: String!
  encoding: String!
}

type Mutation {
  register(
    brand: EmailTempVariablesBrandInput!
    subject: String!
    input: UserInput!
  ): LoginType!
  registerForApp(
    brand: EmailTempVariablesBrandInput!
    subject: String!
    input: UserInput!
  ): LoginType!
  createNewVersion(input: NewVersionInput!): VersionType!
  updateVersion(input: UpdateVersionInput!): VersionType!
  createGlobalCategory(input: GlobalProviderCategoryInput!): GlobalCategoryType!
  updateGlobalCategory(
    input: GlobalProviderCategoryInput!
    id: ID!
  ): GlobalCategoryType!
  deleteGlobalCategory(id: ID!): DeleteResponseDtoType!
  updateVapidKey(input: VapidKeyInput!): VapidKeyType!
  createUser(
    variables: EmailTempVariablesInput
    subject: String!
    input: UserInput!
  ): UserType!
  createUserForApp(
    variables: EmailTempVariablesInput
    input: UserInput!
    subject: String!
  ): UserType!
  updateUser(input: UserUpdateInput!, id: ID!): UserType!
  updateCurrentUser(input: UserUpdateInput!): UserType!
  updateCurrentUserPassword(
    newPassword: String!
    oldPassword: String!
  ): UserType!
  updateCurrentUserPasswordForApp(
    newPassword: String!
    oldPassword: String!
  ): UserType!
  updateCurrentUserEmail(email: String!): LoginType!
  updateCurrentUserLogins(
    email: String
    username: String
    phone: IPhoneInput
  ): LoginType!
  updateUserPasswordForApp(newPassword: String!, id: ID!): UserType!
  updateCurrentUserApp(app: App!): UserType!
  updateUserApp(app: App!, id: String!): UserType!
  sendForgotPasswordMail(
    brand: EmailTempVariablesBrandInput
    subject: String!
    email: String!
  ): MailResponseDto!
  resetPassword(password: String!, token: String!): UserType!
  resetPasswordWithMailForApp(input: ResetPasswordForAppInput!): UserType!
  sendValidMail(
    subject: String!
    variables: EmailTempVariablesInput
  ): MailResponseDto!
  sendMergeAccountsEmail(
    app: App!
    ooredooId: String!
    email: String!
  ): MailResponseDto!
  validateMail(token: String!): UserType!
  validatePhoneNumber(smsNumber: Int!): UserType!
  processWelcomeMail(password: String, token: String!): UserType!
  mergeAccounts(token: String!): UserType!
  deleteUser(
    description: String
    reason: DeleteUserReasonEnum!
    id: ID!
    password: String!
  ): DeleteResponseDtoType!
  saveCurrentUserStatus(status: UserStatus!): UserType!
  saveCurrentUserLocation(
    target: TargetACIInput!
    location: LonLatInput!
  ): UserLocationType!
  createTax(input: TaxInput!): TaxType!
  updateTax(input: TaxInput!, id: ID!): TaxType!
  deleteTax(id: ID!): DeleteResponseDtoType!
  createBrand(input: BrandInput!): BrandType!
  syncOneBrand(input: BrandInput!): BrandType!
  updateBrand(input: BrandInput!, id: String!): BrandType!
  deleteBrand(id: String!): DeleteResponseDtoType!
  insertOrigin(url: String!): OriginType!
  createCompany(input: CompanyInput!): CompanyType!
  updateCompany(input: CompanyUpdateInput!, id: ID!): CompanyType!
  bulkUpdateCompanyMedia(input: [UpdateMediaInput!]!): [CompanyType!]!
  deleteCompany(id: ID!): DeleteResponseDtoType!
  createProduct(input: ProductInput!): ProductType!
  updateProduct(input: ProductUpdateInput!, id: String!): ProductType!
  deleteProduct(id: String!): ProductType!
  updateBarcode(input: BarcodeUpdateInput!): BarcodeType!
  bulkUpdateBarcodeMedia(input: [UpdateMediaInput!]!): [BarcodeType!]!
  createAccount(input: AccountInput!): AccountType!
  addTargetsToAccount(
    targets: TargetsInput!
    roles: [UserPOSRoleEnum!]!
    userId: String!
  ): AccountType!
  updateAccount(expiresAt: DateTime!, accountId: String!): AccountType!
  updateAccountByAdmin(
    input: AccountUpdateInput!
    accountId: String!
  ): AccountType!
  deleteAccount(accountId: String!): DeleteResponseDtoType!
  createAttribute(input: AttributeCreateInput!): AttributeType!
  updateAttribute(input: AttributeUpdateInput!): AttributeType!
  syncOneAttribute(input: AttributeCreateInput!): AttributeType!
  deleteAttribute(id: String!): DeleteResponseDtoType!
  createAttributeValue(input: AttributeValueInput!): AttributeValueType!
  updateAttributeValue(input: AttributeValueUpdateInput!): AttributeValueType!
  syncOneAttributeValue(input: AttributeValueInput!): AttributeValueType!
  deleteAttributeValue(id: ID!): DeleteResponseDtoType!
  createWholesaler(input: WholesalerCreateInput!): WholesalerType!
  updateWholesaler(input: WholesalerUpdateInput!): WholesalerType!
  deleteWholesaler(id: String!): WholesalerType!
  createPOSCategory(input: POSCategoryInput!): POSCategoryType!
  updatePOSCategory(input: POSCategoryInput!, id: String!): POSCategoryType!
  deletePOSCategory(id: String!): POSCategoryType!
  createPointOfSale(input: PointOfSaleInput!): PointOfSaleType!
  updatePointOfSale(input: PointOfSaleInput!, id: ID!): PointOfSaleType!
  deletePointOfSale(id: ID!): PointOfSaleType!
  createPOSServices(input: POSServicesInput!): POSServicesType!
  updatePOSServices(input: POSServicesInput!, id: String!): POSServicesType!
  deletePOSServices(id: String!): POSServicesType!
  createManufacturer(input: ManufacturerCreateInput!): ManufacturerType!
  updateManufacturer(input: ManufacturerUpdateInput!): ManufacturerType!
  deleteManufacturer(id: String!): ManufacturerType!
  insertStaticData(input: StaticDataInput!): StaticDataType!
  createLoyaltyProgram(input: LoyaltyProgramInput!): LoyaltyProgramType!
  updateLoyaltyProgram(
    input: LoyaltyProgramInput!
    id: String!
  ): LoyaltyProgramType!
  deleteLoyaltyProgram(id: ID!): LoyaltyProgramType!
  createMobileWarehouse(userId: String): MobileWarehouseType!
  addToMobileWarehouseStock(
    userId: String
    stocks: [StockInput!]!
  ): MobileWarehouseType!
  removeFromMobileWarehouseStock(
    userId: String
    stocks: [StockInput!]!
  ): MobileWarehouseType!
  createWarehouse(input: WarehouseInput!): WarehouseType!
  updateWarehouse(input: WarehouseUpdateInput!, id: ID!): WarehouseType!
  bulkUpdateWarehouseMedia(input: [UpdateMediaInput!]!): [WarehouseType!]!
  deleteWarehouse(id: ID!): DeleteResponseDtoType!
  createLocation(input: LocationInput!): LocationType!
  updateLocation(input: LocationInput!, id: ID!): LocationType!
  deleteLocation(id: ID!): DeleteResponseDtoType!
  createProductAttribute(input: ProductAttributeInput!): ProductAttributeType!
  updateProductAttribute(
    input: ProductAttributeUpdateInput!
  ): ProductAttributeType!
  deleteProductAttribute(id: String!): DeleteResponseDtoType!
  createInventoryCategory(
    input: InventoryCategoryInput!
  ): InventoryCategoryType!
  updateInventoryCategory(
    input: InventoryCategoryInput!
    id: String!
  ): InventoryCategoryType!
  deleteInventoryCategory(id: String!): InventoryCategoryType!
  createCatalogueCategory(
    input: CatalogueCategoryInput!
  ): CatalogueCategoryType!
  reorderCatalogueCategories(
    target: TargetACIInput!
    catalogCategoryId: String!
    newRank: Float!
  ): [CatalogueCategoryType!]!
  syncOneCategory(input: CatalogueCategoryBulkInput!): CatalogueCategoryType!
  updateCatalogueCategory(
    input: CatalogueCategoryUpdateInput!
  ): CatalogueCategoryType!
  deleteCatalogueCategory(id: ID!): DeleteResponseDtoType!
  createServiceProduct(
    target: TargetACIInput
    input: BarcodeInput!
  ): BarcodeType!
  createSimpleProduct(input: CreateSimpleProductInput!): InternalProductType!
  updateSimpleProduct(input: UpdateSimpleProductInput!): InternalProductType!
  createInternalProduct(
    input: CreateInternalProductInput!
  ): InternalProductType!
  createCustomInternalProduct(
    input: CreateCustomInternalProductInput!
  ): InternalProductType!
  createInternalProductAndProduct(
    externalId: String
    tags: [String!]
    discount: DiscountDtoInput
    internalProductAttributes: InternalProductAttributeInput

    # list of barcodes ids
    barcodes: [ID!]

    # list of suppliers ids
    suppliers: [ID!]
    price: String
    target: TargetACIInput!
    catalogueCategory: [ID!]!
    globalCategory: GlobalCategoryInput
    name: String!
    sku: String
    condition: ProductConditionEnum
    status: ProductStatusEnum
    description: String
    descriptionList: [String!]
    specs: [ProductSpecsInput!]
    picture: PictureInput
    pictures: [PictureInput!]
    media: MediaInput
    ean: String
    weight: Int
    class: [ProductClassEnum!]
    wholesalerPrice: String
    factoryPrice: String
    tax: String!
    structure: ProductStructureEnum
    brand: ID
    category: [ID!]
  ): InternalProductType!
  updateInternalProductAndProduct(
    externalId: String
    tags: [String!]
    discount: DiscountDtoInput
    internalProductAttributes: InternalProductAttributeInput

    # list of barcodes ids
    barcodes: [ID!]

    # list of suppliers ids
    suppliers: [ID!]
    price: String
    catalogueCategory: [ID!]
    globalCategory: GlobalCategoryInput
    name: String
    sku: String
    condition: ProductConditionEnum
    status: ProductStatusEnum
    description: String
    descriptionList: [String!]
    specs: [ProductSpecsInput!]
    picture: PictureInput
    pictures: [PictureInput!]
    media: MediaInput
    ean: String
    weight: Int
    class: [ProductClassEnum!]
    wholesalerPrice: String
    factoryPrice: String
    tax: String
    structure: ProductStructureEnum
    brand: ID
    category: [ID!]
    id: ID!
  ): InternalProductType!
  updateInternalProduct(
    input: UpdateInternalProductInput!
  ): InternalProductType!
  addBarcodeToInternalProductAndProduct(
    barcodeId: ID!
    productId: ID!
    id: ID!
  ): InternalProductType!
  deleteInternalProduct(id: ID!): DeleteResponseDtoType!
  createBarcode(target: TargetACIInput, input: BarcodeInput!): BarcodeType!
  createBarcodeForTarget(
    target: TargetACIInput
    input: BarcodeInput!
  ): BarcodeType!
  deleteBarcode(id: String!): DeleteResponseDtoType!
  createModuleDefinition(input: ModulesDefinitionInput!): ModulesDefinitionType!
  updateModuleDefinition(
    input: ModulesDefinitionInput!
    id: String!
  ): ModulesDefinitionType!
  deleteModuleDefinition(id: ID!): ModulesDefinitionType!
  sendRegistrationValidationSms(
    app: App!
    phone: IPhoneInput!
  ): SmsIntegrationType!
  sendValidSms(app: App!): SmsIntegrationType!
  resetPasswordWithSmsForApp(input: ResetPasswordForAppInput!): UserType!
  createCompanyContact(input: CompanyContactInput!): CompanyContactType!
  updateCompanyContact(
    input: CompanyContactUpdateInput!
    id: ID!
  ): CompanyContactType!
  deleteCompanyContact(id: ID!): DeleteResponseDtoType!
  importPosByExcel(
    # base64 string from excel file.
    base64: String

    # path to excel file in server.
    path: String
  ): SuccessResponseDtoType!
  importFullCorporateCatalogueByExcel(
    target: TargetACIInput!

    # base64 string from excel file.
    base64: String

    # path to excel file in server.
    path: String
    variety: ProductVarietyEnum
  ): SuccessResponseDtoType!
  importSimpleFullCorporateCatalogueByExcel(
    target: TargetACIInput!

    # base64 string from excel file.
    base64: String

    # path to excel file in server.
    path: String
    variety: ProductVarietyEnum
  ): SuccessResponseDtoType!
  importServicesCatalogueByExcel(
    target: TargetACIInput!

    # base64 string from excel file.
    base64: String

    # path to excel file in server.
    path: String
    variety: ProductVarietyEnum
  ): SuccessResponseDtoType!
  importCustomersByExcel(
    target: TargetACIInput!

    # base64 string from excel file.
    base64: String

    # path to excel file in server.
    path: String
    variety: ProductVarietyEnum
  ): SuccessResponseDtoType!
  importSuppliersByExcel(
    target: TargetACIInput!

    # base64 string from excel file.
    base64: String

    # path to excel file in server.
    path: String
    variety: ProductVarietyEnum
  ): SuccessResponseDtoType!
  createModuleAssignment(input: ModulesAssignmentInput!): ModulesAssignmentType!
  updateModuleAssignment(
    input: ModulesAssignmentInput!
    id: String!
  ): ModulesAssignmentType!
  deleteModuleAssignment(id: String!): ModulesAssignmentType!
  createForm(input: CreateFormInput!): FormResponseType!
  updateForm(input: UpdateFormInput!): FormResponseType!
  addQuestionsToForm(
    questions: [QuestionInput!]!
    formId: String!
  ): FormResponseType!
  deleteQuestionsFromForm(
    questions: [String!]!
    formId: String!
  ): FormResponseType!
  updateFormStatus(status: FormStatus!, id: String!): FormResponseType!
  deleteForm(id: ID!): DeleteResponseDtoType!
  createResponse(input: ResponseInput!): ResponseDtoType!
  deleteResponse(id: ID!): DeleteResponseDtoType!
  createOrder(input: OrderAPIInput!): OrderType!
  createWithMobileWarehouse(input: OrderAPIInput!): OrderType!
  updateOrderInstallments(
    installments: [InstallmentInput!]!
    id: String!
  ): OrderType!
  updateOrderStatus(input: OrderStatusInput!): OrderType!
  cancelOrder(orderId: String!): OrderType!
  createPOSBundle(input: POSBundleCreateInput!): POSBundleType!
  updatePOSBundle(input: POSbundleUpdateInput!): POSBundleType!
  addPOSBundleTargets(targets: [String!]!, posBundleId: String!): POSBundleType!
  removePOSBundleTargets(
    targets: [String!]!
    posBundleId: String!
  ): POSBundleType!
  deletePOSBundle(id: String!): POSBundleType!
  addTargets(
    owner: DistributionNetworkOwnerInput
    targets: [POSTargetInput!]!
  ): [DistributionNetworkTargetType!]!
  removeTargets(
    owner: DistributionNetworkOwnerInput
    POSes: [ID!]!
  ): DeleteResponseDtoType!
  deleteDistributionNetwork(id: ID!): DistributionNetworkType!
  addNewCheckin(input: CheckinActivityInput!): CheckinActivityType!
  checkout(id: ID!): CheckinActivityType!
  editCheckin(description: String!, id: ID!): CheckinActivityType!
  createIntegrationSetting(
    input: IntegrationSettingsCreateInput!
  ): IntegrationSettingsType!
  updateIntegrationSetting(
    input: IntegrationSettingsUpdateInput!
  ): IntegrationSettingsType!
  deleteIntegrationSetting(id: String!): IntegrationSettingsType!
  importTransactionByExcel(
    path: String
    base64: String
    user: ID!
    chargeType: ChargeDischargeEnum!
  ): SuccessResponseDtoType!
  createChargeDischarge(input: ChargeDischargeInput!): ChargeDischargeType!
  insertChargesDischarges(
    stocks: [ChargeDischargeInput!]!
  ): DeleteResponseDtoType!
  insertDaysOff(
    user: ID
    color: String
    target: TargetACIInput!
    start: DateTime!
    end: DateTime!
    leaveType: LeaveTypeEnum!
  ): CalendarType!
  updateDaysOff(
    id: ID!
    color: String
    start: DateTime
    end: DateTime
    leaveType: LeaveTypeEnum
  ): CalendarType!
  deleteDaysOff(id: ID!): DeleteResponseDtoType!
  createTeamSettings(
    color: String
    salesObjective: SalesObjectiveInput
    user: ID
    target: TargetACIInput!
  ): TeamSettingsType!
  editTeamSettings(
    id: ID!
    color: String
    salesObjective: SalesObjectiveUpdateInput
  ): TeamSettingsType!
  deleteTeamSettings(id: ID!): DeleteResponseDtoType!
  initStock(
    target: TargetACIInput!

    # barcodeId only provided if barcode is not.
    barcodeId: ID

    # barcode value only provided if barcodeId is not.
    barcode: String
    warehouse: ID
  ): StockType!
  addToStock(
    # stock id to add/remove to/from.
    id: ID!

    # quantity of products to add/remove to/from stock.
    quantity: Int!
    warehouse: ID
  ): StockType!
  addToStockCustom(
    target: TargetACIInput!

    # barcodeId only provided if barcode is not.
    barcodeId: ID

    # barcode value only provided if barcodeId is not.
    barcode: String
    warehouse: ID

    # quantity of products to add/remove to/from stock.
    quantity: Int!
  ): StockType!
  removeFromStock(
    # stock id to add/remove to/from.
    id: ID!

    # quantity of products to add/remove to/from stock.
    quantity: Int!
    warehouse: ID
  ): StockType!
  removeFromStockCustom(
    target: TargetACIInput!

    # barcodeId only provided if barcode is not.
    barcodeId: ID

    # barcode value only provided if barcodeId is not.
    barcode: String
    warehouse: ID

    # quantity of products to add/remove to/from stock.
    quantity: Int!
  ): StockType!
  removeAllFromStock(barcode: ID!): DeleteResponseDtoType!
  createStock(
    target: TargetACIInput!

    # barcodeId only provided if barcode is not.
    barcodeId: ID

    # barcode value only provided if barcodeId is not.
    barcode: String
    warehouse: ID
  ): StockType!
  updateStock(
    # stock id to update.
    id: ID!
    stockCapacity: Int
    minimumStockQuantity: Int
    pixel: StockPixelInput
    outOfStock: Boolean
    warehouse: ID
  ): StockType!
  resetStock(id: ID!): StockType!
  createBarcodeForTargetWithStock(
    target: TargetACIInput
    input: BarcodeInput!
  ): BarcodeType!
  deleteBarcodeWithstock(barcodeId: ID!): DeleteResponseDtoType!
  deleteStock(id: ID!): DeleteResponseDtoType!
  createProductRating(input: ProductRatingInput!): ProductRatingType!
  updateProductRating(
    input: UpdateProductRatingInput!
    id: String!
  ): ProductRatingType!
  deleteProductRating(id: ID!): DeleteResponseDtoType!
  initQualitativeWallet(target: TargetACIInput!, user: String!): WalletDtoType!
  initTargetWallet(target: TargetACIInput!): WalletDtoType!
  initUserWallet: WalletDtoType!
  addUserWallet: WalletDtoType!
  increaseAmount(
    id: ID!
    amount: String!
    usage: PocketUsageType!
    pocketType: PocketTypeEnum!
    target: TargetACIInput
  ): WalletDtoType!
  deductAmount(
    id: ID!
    amount: String!
    usage: PocketUsageType!
    pocketType: PocketTypeEnum!
    target: TargetACIInput
  ): WalletDtoType!
  performTransaction(input: PerformTransactionInput!): DeleteResponseDtoType!
  createOrUpdateOnsiteConverter(
    input: OnsiteConverterInput!
    target: TargetACIInput!
  ): OnsiteConverterType!
  pushOnsiteConverterAmount(
    input: PushConverterInput!
    target: TargetACIInput!
  ): PushAmountResponseType!
  updateLoyaltySettings(
    input: LoyaltySettingsUpdateInput!
  ): LoyaltySettingsType!
  approveLoyaltySubscription(
    # Subscription id.
    id: ID!
  ): SubscribersFullType!
  onboardUserToTargetLoyalty(
    userId: ID!
    target: TargetACIInput!
  ): SuccessResponseDtoType!
  initReputations(target: TargetACIInput!): [ReputationType!]!
  updateReputationLevelPoints(points: Float!, id: String!): [ReputationType!]!
  updateTargetReputation(input: UpdateReputationInput!): ReputationType!
  deleteTargetReputation(id: String!): DeleteResponseDtoType!
  requestSubscription(input: SubscribersInput!): SubscribersFullType!
  subscribeUserToTarget(
    target: TargetACIInput!
    user: String!
  ): SubscribersFullType!
  approveSubscription(
    # Subscription id.
    id: ID!
  ): SubscribersFullType!
  rejectSubscription(
    # Subscription id.
    id: ID!
  ): SubscribersFullType!
  cancelSubscription(userId: ID!, target: TargetACIInput!): SubscribersFullType!
  deleteSubscriber(
    # Subscription id.
    id: ID!
  ): DeleteResponseDtoType!
  generateCorporateUserCard(
    cardTypes: [CardTypeEnum!]
    target: TargetACIInput
    user: ID!
  ): GenerateUserCardType!
  updateCorporateUserCard(
    validUntil: DateTime!
    id: ID!
  ): CorporateUserCardType!
  expireCorporateUserCard(id: ID!): DeleteResponseDtoType!
  createFollower(input: FollowerInput!): FollowerType!
  unfollowTarget(target: TargetACIInput!): DeleteResponseDtoType!
  markAllAsSeenForUser: NotificationResponse!
  markAllAsSeenForPOS(posId: String!): NotificationResponse!
  createAdhocNotification(
    executedAt: DateTime
    picture: PictureInput!
    description: String!
    title: String!
  ): NotificationFullType!
  createCountry(input: CountryInput!): CountryType!
  updateCountry(input: CountryInput!, id: ID!): CountryType!
  deleteCountry(id: ID!): DeleteResponseDtoType!
  createState(input: StateInput!): StateType!
  updateState(input: StateInput!, id: ID!): StateType!
  deleteState(id: ID!): DeleteResponseDtoType!
  createLanguage(input: LanguageInput!): LanguageType!
  updateLanguage(input: LanguageInput!, id: ID!): LanguageType!
  deleteLanguage(id: ID!): DeleteResponseDtoType!
  createSocial(input: SocialInput!): SocialType!
  updateSocial(input: SocialInput!, id: ID!): SocialType!
  deleteSocial(id: ID!): DeleteResponseDtoType!
  createPayment(input: PaymentInput!): PaymentType!
  updatePayment(input: PaymentInput!, id: ID!): PaymentType!
  deletePayment(id: ID!): DeleteResponseDtoType!
  createBrowser(input: BrowserInput!): BrowserType!
  updateBrowser(input: BrowserInput!, id: ID!): BrowserType!
  deleteBrowser(id: ID!): DeleteResponseDtoType!
  createTechDevice(input: TechDeviceInput!): TechDeviceType!
  updateTechDevice(input: TechDeviceInput!, id: ID!): TechDeviceType!
  deleteTechDevice(id: ID!): DeleteResponseDtoType!
  createTechDeviceBrand(input: TechDeviceBrandInput!): TechDeviceBrandType!
  updateTechDeviceBrand(
    input: TechDeviceBrandInput!
    id: ID!
  ): TechDeviceBrandType!
  deleteTechDeviceBrand(id: ID!): DeleteResponseDtoType!
  createTechDeviceType(input: TechDeviceTypeInput!): TechDeviceTypeType!
  updateTechDeviceType(
    input: TechDeviceTypeInput!
    id: ID!
  ): TechDeviceTypeType!
  deleteTechDeviceType(id: ID!): DeleteResponseDtoType!
  createOperatingSystem(input: OperatingSystemInput!): OperatingSystemType!
  updateOperatingSystem(
    input: OperatingSystemInput!
    id: ID!
  ): OperatingSystemType!
  deleteOperatingSystem(id: ID!): DeleteResponseDtoType!
  createBank(input: BankInput!): BankType!
  updateBank(input: BankInput!, id: ID!): BankType!
  deleteBank(id: ID!): DeleteResponseDtoType!
  createBankDetails(input: BankDetailsInput!): BankDetailsType!
  updateBankDetails(input: BankDetailsInput!, id: ID!): BankDetailsType!
  deleteBankDetails(id: ID!): DeleteResponseDtoType!
  createEmailTemplate(input: EmailTemplateInput!): EmailTemplateType!
  updateEmailTemplate(input: EmailTemplateInput!, id: ID!): EmailTemplateType!
  deleteEmailTemplate(id: ID!): DeleteResponseDtoType!
  getWeatherFromProvider: WeatherType!
  createWeatherIcon(input: WeatherIconsInput!): WeatherIconsType!
  createPosAttributes(input: PosAttributesInput!): PosAttributesType!
  createOrUpdatePosAttributes(input: PosAttributesInput!): PosAttributesType!
  updatePosAttributes(input: PosAttributesInput!, id: ID!): PosAttributesType!
  deletePosAttributes(id: ID!): DeleteResponseDtoType!
  createVisibilityClassification(
    input: VisibilityClassificationInput!
  ): VisibilityClassificationType!
  updateVisibilityClassification(
    input: VisibilityClassificationInput!
    id: ID!
  ): VisibilityClassificationType!
  deleteVisibilityClassification(id: ID!): DeleteResponseDtoType!
  createVisibilityItem(input: VisibilityItemInput!): VisibilityItemType!
  updateVisibilityItem(
    input: VisibilityItemInput!
    id: ID!
  ): VisibilityItemType!
  deleteVisibilityItem(id: ID!): DeleteResponseDtoType!
  createVisibilitySection(
    input: VisibilitySectionInput!
  ): VisibilitySectionType!
  updateVisibilitySection(
    input: VisibilitySectionInput!
    id: ID!
  ): VisibilitySectionType!
  deleteVisibilitySection(id: ID!): DeleteResponseDtoType!
  createPosVisibility(input: PosVisibilityInput!): PosVisibilityType!
  updatePosVisibility(input: PosVisibilityInput!, id: ID!): PosVisibilityType!
  deletePosVisibility(id: ID!): DeleteResponseDtoType!
  createMerchDataType(input: MerchDataTypeInput!): MerchDataTypeType!
  updateMerchDataType(
    input: MerchDataTypeInput!
    id: String!
  ): MerchDataTypeType!
  deleteMerchDataType(id: String!): MerchDataTypeType!
  createMerchData(input: MerchDataInput!): MerchDataType!
  updateMerchData(input: MerchDataInput!, id: String!): MerchDataType!
  deleteMerchData(id: String!): MerchDataType!
}

input UserInput {
  email: String
  username: String
  phone: IPhoneInput
  password: String!
  picture: PictureInput
  pictures: [PictureInput!]
  covers: [PictureInput!]
  firstName: String
  status: UserStatus
  title: String
  about: String
  lastName: String
  maritalStatus: MaritalStatus
  gender: Gender
  languages: [String!]
  isMailValid: Boolean
  plugged: Boolean
  dateOfBirth: DateTime
  chatContact: [SocialValueInput!]
  socialMedia: [SocialValueInput!]
  nationality: String
  locale: String
  placeOfBirth: String
  residentialAddress: [FullAddressInput!]
  shippingAddress: [FullAddressInput!]
  billingAddress: [FullAddressInput!]
  mobileTheme: MobileThemesEnum
  source: SourcesEnum
  newsletterSubs: Boolean
  roles: [UserRole!]!
  apps: [App!]
  phoneNumber: String
}

input SocialValueInput {
  name: ID!
  value: String!
}

input NewVersionInput {
  platform: PlatformEnum
  requireUpdate: Boolean
  versionContent: [VersionContentInput!]
  version: String!
}

input VersionContentInput {
  contentType: VersionContentTypeEnum
  content: String
}

input UpdateVersionInput {
  platform: PlatformEnum
  requireUpdate: Boolean
  versionContent: [VersionContentInput!]
  id: ID!
  version: String
}

input GlobalProviderCategoryInput {
  identifier: Int!
  name: String!
  provider: GlobalCategoryProviderEnum
}

input VapidKeyInput {
  vapidKey: String!
  userId: String!
}

input UserUpdateInput {
  password: String
  picture: PictureInput
  pictures: [PictureInput!]
  covers: [PictureInput!]
  firstName: String
  status: UserStatus
  title: String
  about: String
  lastName: String
  maritalStatus: MaritalStatus
  gender: Gender
  languages: [String!]
  isMailValid: Boolean
  plugged: Boolean
  dateOfBirth: DateTime
  chatContact: [SocialValueInput!]
  socialMedia: [SocialValueInput!]
  nationality: String
  locale: String
  placeOfBirth: String
  residentialAddress: [FullAddressInput!]
  shippingAddress: [FullAddressInput!]
  billingAddress: [FullAddressInput!]
  mobileTheme: MobileThemesEnum
  source: SourcesEnum
  newsletterSubs: Boolean
  roles: [UserRole!]
  apps: [App!]
  phoneNumber: String
  email: String
  username: String
  phone: IPhoneInput
  vapidKey: String
}

input ResetPasswordForAppInput {
  password: String!
  token: String
  smsValidationCode: Int
  phone: IPhoneInput
}

enum DeleteUserReasonEnum {
  LACK_OF_CONTENT
  SOMETHING_IS_BROKEN
  SIZE_AND_COMPATIBILITY
}

input TaxInput {
  label: String
  externalId: String
  value: TaxValueInput
  use: [TaxUseEnum!]
  product: Boolean
  company: ID
}

input TaxValueInput {
  sign: TaxSignEnum!
  value: String
  type: DiscountType!
}

input BrandInput {
  name: String!
  picture: PictureInput
  externalId: String
  website: String
  manufacturer: String
  target: TargetACIInput
}

input CompanyInput {
  name: String
  description: String
  tags: [String!]
  media: MediaInput
  address: FullAddressInput
  legal: CompanyLegalInput
  banks: [String!]
  contact: CompanyContactDetailsInput
  logistic: Boolean
  externalId: String
  customer: CompanyCustomerInput
  supplier: CompanySupplierInput
  target: TargetACIInput
}

input MediaInput {
  videos: [String!]
  pictures: [PictureInput!]
  deg360: [PictureInput!]
}

input CompanyLegalInput {
  vat: String
  register: String
  licence: String
}

input CompanyContactDetailsInput {
  website: String
  email: String
  phone: PhoneInput
}

input PhoneInput {
  # Phone number
  number: String

  # Phone country code
  countryCode: String
  isValid: Boolean
}

input CompanyCustomerInput {
  phase: CustomerPhaseEnum
  score: String
}

input CompanySupplierInput {
  kind: SupplierTypeEnum
}

input CompanyUpdateInput {
  name: String
  description: String
  tags: [String!]
  media: MediaInput
  address: FullAddressInput
  legal: CompanyLegalInput
  banks: [String!]
  contact: CompanyContactDetailsInput
  logistic: Boolean
  externalId: String
  customer: CompanyCustomerInput
  supplier: CompanySupplierInput
}

input UpdateMediaInput {
  id: ID!
  media: SingleMediaInput!
}

input SingleMediaInput {
  videos: String
  pictures: PictureInput
  deg360: PictureInput
}

input ProductInput {
  externalId: String
  name: String!
  sku: String
  description: String
  descriptionList: [String!]
  specs: [ProductSpecsInput!]
  tags: [String!]
  picture: PictureInput
  pictures: [PictureInput!]
  media: MediaInput
  ean: String
  weight: Float
  price: String!
  class: [ProductClassEnum!]
  wholesalerPrice: String
  factoryPrice: String
  tax: String!
  taxes: [ProductTaxesInput!]
  productAttributes: [String!]

  # list of barcodes ids
  barcodes: [ID!]
  brand: String
  category: [String!]!
}

input ProductSpecsInput {
  key: String
  value: String
}

input ProductUpdateInput {
  externalId: String
  name: String
  sku: String
  description: String
  descriptionList: [String!]
  specs: [ProductSpecsInput!]
  tags: [String!]
  picture: PictureInput
  pictures: [PictureInput!]
  media: MediaInput
  ean: String
  weight: Float
  price: String
  class: [ProductClassEnum!]
  wholesalerPrice: String
  factoryPrice: String
  tax: String
  taxes: [ProductTaxesInput!]
  productAttributes: [String!]

  # list of barcodes ids
  barcodes: [ID!]
  brand: String
  category: [String!]
}

input BarcodeUpdateInput {
  product: ID
  internalProduct: ID
  productAttributesValues: [ID!]
  barcode: String
  name: String
  price: String
  priceCredit: [BarcodePeriodCreditInput!]
  discount: DiscountDtoInput
  condition: ProductConditionEnum
  status: ProductStatusEnum
  media: MediaInput
  catalogueCategory: [String!]
  maintenance: InternalProductMaintenanceInput
  pixel: PixelBarcodeInput
  priceList: [ProductPriceListInput!]
  taxes: [ProductTaxesInput!]
  supplier: ID
  id: ID!
}

input BarcodePeriodCreditInput {
  periodCycle: RecurrenceType!
  periodValue: Int!
  amount: String
}

input InternalProductMaintenanceInput {
  active: Boolean
  owner: ID
  technician: ID
  prevMaintenanceDuration: Int
  maintenanceDuration: Int
  expectedMeantime: Int
}

input PixelBarcodeInput {
  include: Boolean
}

input ProductPriceListInput {
  price: ID!
  value: String
}

input AccountInput {
  expiresAt: DateTime!
  user: String!
  targets: TargetsInput!
}

enum UserPOSRoleEnum {
  POS_OWNER
  POS_WAITER
  POS_MANAGER
  DELIVERY_MAN
  POS_ASSISTANT
}

input AccountUpdateInput {
  expiresAt: DateTime
  user: String
  targets: TargetsInput
}

input AttributeCreateInput {
  label: String!
  externalId: String!
  isRequired: Boolean
  isMultipleChoice: Boolean
  pixel: AttributePixelInput
  variety: ProductVarietyEnum
  target: TargetACIInput
}

input AttributePixelInput {
  pixelAttribute: String
}

input AttributeUpdateInput {
  label: String
  isRequired: Boolean
  isMultipleChoice: Boolean
  pixel: AttributePixelInput
  variety: ProductVarietyEnum
  id: ID!
}

input AttributeValueInput {
  label: String!
  externalId: String!
  target: TargetACIInput!
  attribute: ID!
}

input AttributeValueUpdateInput {
  label: String
  attribute: ID
  id: ID!
}

input WholesalerCreateInput {
  name: String
  description: String
  address: FullAddressInput
  picture: PictureInput
  email: String
  company: String
  website: String
  contactEmails: [String!]
  phone: IPhoneInput
  fax: IPhoneInput
}

input WholesalerUpdateInput {
  name: String
  description: String
  address: FullAddressInput
  picture: PictureInput
  email: String
  company: String
  website: String
  contactEmails: [String!]
  phone: IPhoneInput
  fax: IPhoneInput
  id: String!
}

input POSCategoryInput {
  name: String!
  mapPicture: String!
  picture: PictureInput
}

input PointOfSaleInput {
  name: String
  title: String
  subtitle: String
  description: String
  tags: [String!]
  brandColor: String
  reference: String
  published: Boolean
  picture: PictureInput
  outsidePictures: [PictureInput!]
  insidePictures: [PictureInput!]
  openingHours: OpeningHoursInput
  specialOffers: [SpecilOfferInput!]
  locations: [FullAddressInput!]
  email: [String!]
  contactEmails: [String!]
  currency: Currency
  languages: [ID!]
  phone: [String!]
  website: String
  chatContact: [SocialValueInput!]
  socialMedia: [SocialValueInput!]
  averageCustomers: Float
  turnover: String
  posCategory: [ID!]
  company: String
  services: [ID!]
  paymentMethods: [ID!]
  loyaltyPrograms: [POSLoyaltyInput!]
}

input OpeningHoursInput {
  status: OpeningStatus!
  hours: [OpeningHoursDayInput!]!
}

input OpeningHoursDayInput {
  day: Days!
  from: String!
  to: String!
}

input SpecilOfferInput {
  offerType: SpecialOffersType
  hours: [OpeningHoursDayInput!]
}

input POSLoyaltyInput {
  loyaltyProgram: String
  from: DateTime!
  to: DateTime!
}

input POSServicesInput {
  index: Int!
  name: String!
}

input ManufacturerCreateInput {
  name: String
  picture: PictureInput
  externalId: String
  address: FullAddressInput
  email: String
  company: String
  contactEmails: [String!]
  website: String
}

input ManufacturerUpdateInput {
  name: String
  picture: PictureInput
  externalId: String
  address: FullAddressInput
  email: String
  company: String
  contactEmails: [String!]
  website: String
  id: String!
}

input StaticDataInput {
  key: String!
  value: String!
}

input LoyaltyProgramInput {
  programName: String!
  picture: PictureInput
  company: String!
}

input StockInput {
  barcode: ID!
  quantity: Int!
}

input WarehouseInput {
  name: String
  media: MediaInput
  tags: [String!]
  location: ID!
  totalSurface: Float
  nonStorageSurface: Float
  externalId: String
}

input WarehouseUpdateInput {
  name: String
  media: MediaInput
  tags: [String!]
  location: ID
  totalSurface: Float
  nonStorageSurface: Float
  externalId: String
}

input LocationInput {
  name: String
  externalId: String
  media: MediaInput
  tags: [String!]
  company: ID
  address: FullAddressInput
  locationType: LocationTypeEnum
}

input ProductAttributeInput {
  isRequired: Boolean
  isMultipleChoice: Boolean
  attribute: String!
  reference: String!
  possibleValues: [String!]!
  target: TargetACIInput
}

input ProductAttributeUpdateInput {
  isRequired: Boolean
  isMultipleChoice: Boolean
  id: ID!
  attribute: String
  reference: String
  possibleValues: [String!]
}

input InventoryCategoryInput {
  name: String!
  picture: PictureInput
  layer: Int!
  rank: Int!
  hasChildren: Boolean!
  parent: String
}

input CatalogueCategoryInput {
  portal: Boolean
  pickup: Boolean
  booking: Boolean
  delivery: Boolean
  parent: String
  description: String
  externalId: String
  pictures: [PictureInput!]
  seo: CatalogueCategorySeoInput
  variety: ProductVarietyEnum
  name: String!
  target: TargetACIInput!
  layer: Int!
}

input CatalogueCategorySeoInput {
  urlKey: String
  metaTitle: String
  metaDesription: String
  metaKeywords: [MetaKeywordsInput!]
}

input MetaKeywordsInput {
  name: String
  content: String
}

input CatalogueCategoryBulkInput {
  portal: Boolean
  pickup: Boolean
  booking: Boolean
  delivery: Boolean
  parent: ID
  description: String
  externalId: String!
  pictures: [PictureInput!]
  seo: CatalogueCategorySeoInput
  variety: ProductVarietyEnum
  name: String!
  hasChildren: Boolean!
  target: TargetACIInput!
  rank: Int!
  layer: Int!
}

input CatalogueCategoryUpdateInput {
  portal: Boolean
  pickup: Boolean
  booking: Boolean
  delivery: Boolean
  parent: String
  description: String
  externalId: String
  pictures: [PictureInput!]
  seo: CatalogueCategorySeoInput
  variety: ProductVarietyEnum
  id: ID!
  name: String
  layer: Int
}

input BarcodeInput {
  product: ID
  internalProduct: ID
  productAttributesValues: [ID!]
  barcode: String!
  name: String
  price: String
  priceCredit: [BarcodePeriodCreditInput!]
  discount: DiscountDtoInput
  condition: ProductConditionEnum
  status: ProductStatusEnum
  media: MediaInput
  catalogueCategory: [String!]
  maintenance: InternalProductMaintenanceInput
  pixel: PixelBarcodeInput
  priceList: [ProductPriceListInput!]
  taxes: [ProductTaxesInput!]
  supplier: ID
}

input CreateSimpleProductInput {
  name: String
  description: String
  descriptionList: [String!]
  specs: [ProductSpecsInput!]
  externalId: String
  tags: [String!]
  class: [ProductClassEnum!]
  structure: ProductStructureEnum
  variety: ProductVarietyEnum
  condition: ProductConditionEnum
  status: ProductStatusEnum
  rent: Boolean
  discount: DiscountDtoInput
  sku: String
  seo: CatalogueCategorySeoInput
  brand: String
  picture: PictureInput
  pictures: [PictureInput!]
  media: MediaInput

  # list of suppliers ids
  suppliers: [ID!]
  price: String
  target: TargetACIInput!
  catalogueCategory: [String!]
  globalCategory: GlobalCategoryInput
}

input GlobalCategoryInput {
  googleCategory: ID
  facebookCategory: ID
}

input UpdateSimpleProductInput {
  name: String
  description: String
  descriptionList: [String!]
  specs: [ProductSpecsInput!]
  externalId: String
  tags: [String!]
  class: [ProductClassEnum!]
  structure: ProductStructureEnum
  variety: ProductVarietyEnum
  condition: ProductConditionEnum
  status: ProductStatusEnum
  rent: Boolean
  discount: DiscountDtoInput
  sku: String
  seo: CatalogueCategorySeoInput
  brand: String
  picture: PictureInput
  pictures: [PictureInput!]
  media: MediaInput

  # list of suppliers ids
  suppliers: [ID!]
  price: String
  catalogueCategory: [String!]
  globalCategory: GlobalCategoryInput
  id: ID!
}

input CreateInternalProductInput {
  name: String
  description: String
  descriptionList: [String!]
  specs: [ProductSpecsInput!]
  externalId: String
  tags: [String!]
  class: [ProductClassEnum!]
  structure: ProductStructureEnum
  variety: ProductVarietyEnum
  condition: ProductConditionEnum
  status: ProductStatusEnum
  rent: Boolean
  discount: DiscountDtoInput
  sku: String
  seo: CatalogueCategorySeoInput
  brand: String
  picture: PictureInput
  pictures: [PictureInput!]
  media: MediaInput
  internalProductAttributes: InternalProductAttributeInput

  # list of barcodes ids
  barcodes: [ID!]

  # list of suppliers ids
  suppliers: [ID!]
  price: String
  product: String!
  target: TargetACIInput!
  catalogueCategory: [String!]
  globalCategory: GlobalCategoryInput
}

input InternalProductAttributeInput {
  attributes: [InternalProductAttributeInnerInput!]
}

input InternalProductAttributeInnerInput {
  price: String
  selectedValue: String!
  productAttribute: String!
}

input CreateCustomInternalProductInput {
  name: String
  description: String
  descriptionList: [String!]
  specs: [ProductSpecsInput!]
  externalId: String
  tags: [String!]
  class: [ProductClassEnum!]
  structure: ProductStructureEnum
  variety: ProductVarietyEnum
  condition: ProductConditionEnum
  status: ProductStatusEnum
  rent: Boolean
  discount: DiscountDtoInput
  sku: String
  seo: CatalogueCategorySeoInput
  brand: String
  picture: PictureInput
  pictures: [PictureInput!]
  media: MediaInput
  internalProductAttributes: InternalProductAttributeInput

  # list of barcodes ids
  barcodes: [ID!]

  # list of suppliers ids
  suppliers: [ID!]
  price: String!
  product: String
  target: TargetACIInput!
  productInput: ProductInput
  catalogueCategory: [String!]!
  globalCategory: GlobalCategoryInput
}

input UpdateInternalProductInput {
  name: String
  description: String
  descriptionList: [String!]
  specs: [ProductSpecsInput!]
  externalId: String
  tags: [String!]
  class: [ProductClassEnum!]
  structure: ProductStructureEnum
  variety: ProductVarietyEnum
  condition: ProductConditionEnum
  status: ProductStatusEnum
  rent: Boolean
  discount: DiscountDtoInput
  sku: String
  seo: CatalogueCategorySeoInput
  brand: String
  picture: PictureInput
  pictures: [PictureInput!]
  media: MediaInput
  internalProductAttributes: InternalProductAttributeInput

  # list of barcodes ids
  barcodes: [ID!]

  # list of suppliers ids
  suppliers: [ID!]
  price: String
  product: String
  catalogueCategory: [String!]
  globalCategory: GlobalCategoryInput
  id: ID!
}

input ModulesDefinitionInput {
  name: String!
  target: TargetTypeEnum
}

input CompanyContactInput {
  firstName: String
  lastName: String
  email: String
  phone: IPhoneInput
  dateOfBirth: DateTime
  chatContact: [SocialValueInput!]
  socialMedia: [SocialValueInput!]
  lastContacted: DateTime
  leadScore: String
  media: MediaInput
  tags: [String!]
  externalId: String
  company: ID
  address: FullAddressInput
}

input CompanyContactUpdateInput {
  firstName: String
  lastName: String
  email: String
  phone: IPhoneInput
  dateOfBirth: DateTime
  chatContact: [SocialValueInput!]
  socialMedia: [SocialValueInput!]
  lastContacted: DateTime
  leadScore: String
  media: MediaInput
  tags: [String!]
  externalId: String
  address: FullAddressInput
}

input ModulesAssignmentInput {
  module: String!
  assignee: AssigneeInput
}

input CreateFormInput {
  title: String!
  description: String!
  owner: FormOwnerInput!
  questions: [QuestionInput!]!
  type: FormType!
  status: FormStatus!
}

input FormOwnerInput {
  pos: String
  wholesaler: String
  manufacturer: String
}

input QuestionInput {
  mandatory: Boolean!
  title: String!
  choices: [String!]
  order: Int
  type: QuestionTypeEnum!
  challengeStep: ID
  score: Boolean
  points: Int
}

input UpdateFormInput {
  id: String!
  title: String
  description: String
  owner: FormOwnerInput
  questions: [UpdateQuestionInput!]
  type: FormType
  status: FormStatus
}

input UpdateQuestionInput {
  mandatory: Boolean!
  title: String!
  choices: [String!]
  order: Int
  type: QuestionTypeEnum!
  challengeStep: ID
  score: Boolean
  points: Int
  id: ID!
}

input ResponseInput {
  question: String!
  target: TargetInput
  answers: [String!]!
}

input TargetInput {
  pos: String
  user: String
}

input OrderAPIInput {
  user: String
  executor: ExecutorEnum!
  pos: String!
  target: OwnerOrTargetInput!
  installments: [InstallmentInput!]
  order: [OrderProductInput!]!
}

enum ExecutorEnum {
  POS
  COMERCIAL
}

input OrderProductInput {
  barcode: String!
  quantity: Int!
}

input OrderStatusInput {
  orderId: ID!
  status: OrderStatus!
}

input POSBundleCreateInput {
  name: String!
  reduction: String!
  conversionRate: Int
  owner: OwnerOrTargetInput!
  targets: [String!]!
}

input POSbundleUpdateInput {
  id: String!
  name: String
  reduction: String
  conversionRate: Int
  owner: OwnerOrTargetInput
  targets: [String!]
}

input POSTargetInput {
  pos: ID!
  reference: String!
}

input CheckinActivityInput {
  pos: String!
  user: String
  checkinType: CheckinTypeEnum!
  description: String
  owner: CheckinActivityOwnerInput!
}

input CheckinActivityOwnerInput {
  wholesaler: String
  manufacturer: String
}

input IntegrationSettingsCreateInput {
  target: OwnerOrTargetInput!
  url: String!
  username: String!
  password: String
}

input IntegrationSettingsUpdateInput {
  id: String!
  target: OwnerOrTargetInput
  url: String
  username: String
  password: String
}

input ChargeDischargeInput {
  user: String!
  stock: [StockInput!]!
  chargeType: ChargeDischargeEnum!
}

input SalesObjectiveInput {
  value: String!
  start: DateTime!
  end: DateTime!
}

input SalesObjectiveUpdateInput {
  value: String
  start: DateTime
  end: DateTime
}

input StockPixelInput {
  quantityToSellOnFacebook: Int
}

input ProductRatingInput {
  mark: Int!
  comment: String
  user: ID!
  product: ID!
  reviewType: ID!
}

input UpdateProductRatingInput {
  mark: Int
  comment: String
  user: ID
  product: ID
  reviewType: ID
}

input PerformTransactionInput {
  source: TargetTransferInput!
  receiver: TargetTransferInput!
  amount: String!
}

input TargetTransferInput {
  # user id
  user: String

  # pos id
  pos: String

  # wholesaler id
  wholesaler: String

  # manufacturer id
  manufacturer: String
}

input OnsiteConverterInput {
  remunerations: [RemunerationWithReputationInput!]!
}

input RemunerationWithReputationInput {
  qualitativeAmount: String!
  quantitativeAmount: String!
  reputationLevel: ID
}

input PushConverterInput {
  user: String!
  amount: String!
}

input LoyaltySettingsUpdateInput {
  qualitative: LoyaltySettingsWalletInput
  quantitative: LoyaltySettingsWalletInput
  onsiteConverter: LoyaltySettingsOnsiteConverterinput
  loyaltyCard: LoyaltySettingsWalletCardInput
  leaderboard: LoyaltySettingsWalletLeaderboardInput
  subscribers: LoyaltySettingsWalletSubscribersInput
  id: ID!
}

input LoyaltySettingsWalletInput {
  active: Boolean
  picture: PictureInput
}

input LoyaltySettingsOnsiteConverterinput {
  active: Boolean
  onsiteConverter: ID
  cashregisterIntegration: LoyaltySettingsOnsiteConverterIntgInput
}

input LoyaltySettingsOnsiteConverterIntgInput {
  active: Boolean
  credentials: APICredentialsInput
}

input APICredentialsInput {
  publicKey: String
  secretKey: String
}

input LoyaltySettingsWalletCardInput {
  digital: Boolean
  physical: Boolean
  validity: Int
}

input LoyaltySettingsWalletLeaderboardInput {
  active: Boolean
  overall: Boolean
  monthly: Boolean
  weekly: Boolean
}

input LoyaltySettingsWalletSubscribersInput {
  verification: Boolean
}

input UpdateReputationInput {
  id: ID!
  inactivityCycle: Int
  lossAmount: Int
  perks: PerksInput
  color: String
  reputationLevel: String
  picture: UpdatePictureInput
}

input PerksInput {
  discount: String
  description: String!
}

input UpdatePictureInput {
  width: Int
  height: Int
  x: Int
  y: Int
  alt: String
  baseUrl: String
  path: String
}

input SubscribersInput {
  target: TargetACIInput!
  user: String
}

input FollowerInput {
  target: TargetACIInput
  user: String
}

input CountryInput {
  name: String!
  code: String
  dialCode: String
  flagSquare: PictureInput
  flagWide: PictureInput
  iconFlag: String
}

input StateInput {
  name: String!
  code: String
  created: DateTime!
  surface: String!
  dialCode: String
  flagSquare: PictureInput
  flagWide: PictureInput
  country: ID
}

input LanguageInput {
  name: String!
  code: String
  flagSquare: PictureInput
  flagWide: PictureInput
  iconFlag: String
}

input SocialInput {
  name: String!
  code: String
  fontIcon: String
  images: [SocialImagesInput!]
}

input SocialImagesInput {
  style: SocialImageStyleEnum!
  images: [SocialImagesImagesInput!]
}

input SocialImagesImagesInput {
  svg: SocialImagesImagesSetInput
  png: SocialImagesImagesSetInput
}

input SocialImagesImagesSetInput {
  size48: PictureInput
  size96: PictureInput
  size144: PictureInput
  size240: PictureInput
  size480: PictureInput
}

input PaymentInput {
  name: String!
  code: String
  paymentType: PaymentTypeEnum
  materialIcon: String
  images: PaymentImagesInput
}

input PaymentImagesInput {
  svg: PaymentImagesSvgInput
  png: PaymentImagesPngInput
}

input PaymentImagesSvgInput {
  alt: PictureInput
  card_flat: PictureInput
  dark: PictureInput
  flat: PictureInput
  light: PictureInput
  default: PictureInput
}

input PaymentImagesPngInput {
  alt: PictureInput
  alt2x: PictureInput
  alt_128: PictureInput
  alt_256: PictureInput
  alt_512: PictureInput
  card_flat: PictureInput
  card_flat2x: PictureInput
  card_flat_128: PictureInput
  card_flat_256: PictureInput
  card_flat_512: PictureInput
  dark: PictureInput
  dark2x: PictureInput
  dark_128: PictureInput
  dark_256: PictureInput
  dark_512: PictureInput
  flat: PictureInput
  flat2x: PictureInput
  flat_128: PictureInput
  flat_256: PictureInput
  flat_512: PictureInput
  light: PictureInput
  light2x: PictureInput
  light_128: PictureInput
  light_256: PictureInput
  light_512: PictureInput
  default: PictureInput
  default2x: PictureInput
  default_128: PictureInput
  default_256: PictureInput
  default_512: PictureInput
}

input BrowserInput {
  name: String
  tags: [String!]
  code: String!
  logo: BrowserLogoInput
}

input BrowserLogoInput {
  svg: PictureInput
  png: BrowserLogoPngInput
  icon: String
}

input BrowserLogoPngInput {
  default: PictureInput
  size16: PictureInput
  size24: PictureInput
  size32: PictureInput
  size48: PictureInput
  size64: PictureInput
  size128: PictureInput
  size256: PictureInput
  size512: PictureInput
}

input TechDeviceInput {
  name: String
  tags: [String!]
  code: String
  picture: PictureInput
  releasedat: String
  body: String
  os: String
  storage: String
  displaySize: String
  displayResolution: String
  cameraPixels: String
  videoPixels: String
  ram: String
  chipset: String
  batterySize: String
  batteryType: String
  specifications: TechDeviceSpecsInput
  brand: ID
}

input TechDeviceSpecsInput {
  technology: String
  band2g: String
  gprs: String
  edge: String
  announced: String
  status: String
  dimensions: String
  weight: String
  sim: String
  type: String
  size: String
  resolution: String
  cardSlot: String
  phonebook: String
  callRecords: String
  loudspeaker: String
  alertTypes: String
  jack35mm: String
  wlan: String
  bluetooth: String
  gps: String
  radio: String
  usb: String
  sensors: String
  messaging: String
  browser: String
  clock: String
  alarm: String
  games: String
  languages: String
  java: String
  colors: String
}

input TechDeviceBrandInput {
  name: String!
  code: String
  tags: [String!]
  logo: DeviceBrandLogoInput
}

input DeviceBrandLogoInput {
  svg: PictureInput
  png: DeviceBrandLogoPngInput
  icon: String
}

input DeviceBrandLogoPngInput {
  default: PictureInput
  size16: PictureInput
  size24: PictureInput
  size32: PictureInput
  size48: PictureInput
  size64: PictureInput
  size128: PictureInput
  size256: PictureInput
  size512: PictureInput
}

input TechDeviceTypeInput {
  name: String
  tags: [String!]
  nodeName: String
  code: String
  pictureSquare: PictureInput
  pictureWide: PictureInput
  icon: String
}

input OperatingSystemInput {
  name: String!
  code: String
  tags: [String!]
  slug: String
  logo: OSLogoInput
}

input OSLogoInput {
  svg: PictureInput
  png: OSLogoPngInput
  icon: String
}

input OSLogoPngInput {
  default: PictureInput
  size16: PictureInput
  size24: PictureInput
  size32: PictureInput
  size48: PictureInput
  size64: PictureInput
  size128: PictureInput
}

input BankInput {
  name: String!
  code: String
  bic: String
  address: FullAddressInput
  logo: BrowserLogoInput
}

input BankDetailsInput {
  account: String!
  iban: String
  bank: ID!
  externalId: String
  holder: BankDetailsHolderInput!
}

input BankDetailsHolderInput {
  name: String
  type: BankDetailsHolderTypeEnum
  address: FullAddressInput
}

input EmailTemplateInput {
  name: EmailTemplateTypeEnum!
  content: String!
}

input WeatherIconsInput {
  code: Float
  description: String
  icon: WeatherIconsDetailInput
  iconify: WeatherIconsDetailInput
}

input WeatherIconsDetailInput {
  day: String
  night: String
}

input PosAttributesInput {
  general: PosAttributesGeneralInput!
  criteria: PosAttributesCriteriaInput!
  dte: PosAttributesDteInput!
  volume: PosAttributesVolumeInput!
  pos: ID!
}

input PosAttributesGeneralInput {
  heetsHandler: Boolean!
  nLicences: Int!
}

input PosAttributesCriteriaInput {
  location: PosAttributesLocationEnum!
  traffic: PosAttributesCriteriaTrafficInput!
}

input PosAttributesCriteriaTrafficInput {
  consumer: PosAttributesTrafficEnum!
  wholesaler: PosAttributesTrafficEnum!
}

input PosAttributesDteInput {
  code: String!
  hypercare: Boolean!
}

input PosAttributesVolumeInput {
  handlerQuantity: PosAttributesVolumeHandlerInput!
}

input PosAttributesVolumeHandlerInput {
  monthlyCc: Float!
  monthlyRrp: Float!
}

input VisibilityClassificationInput {
  title: String!
  description: String
  icon: String
  media: MediaInput
  sections: [ID!]
  flag: Boolean
}

input VisibilityItemInput {
  title: String!
  description: String
  icon: String
  media: MediaInput
  classification: ID
}

input VisibilitySectionInput {
  title: String
  description: String
  icon: String
  media: MediaInput
  owner: VisibilityOwnerEnum!
  target: TargetACIInput
}

input PosVisibilityInput {
  section: ID!
  pos: ID!
  target: TargetACIInput
  items: [PosVisibilityItemInput!]!
}

input PosVisibilityItemInput {
  classification: ID!
  value: PosVisibilityItemValueInput!
}

input PosVisibilityItemValueInput {
  item: [ID!]
  flag: Boolean
}

input MerchDataTypeInput {
  title: String!
  description: String
  icon: String
  media: MediaInput
  target: TargetACIInput!
  product: Boolean!
  categories: [ID!]
  enable: Boolean!
  recurrence: RecurrenceType!
}

input MerchDataInput {
  datatype: ID!
  pos: ID!
  article: ID!
  value: String!
  period: MerchDataPeriodInput!
}

input MerchDataPeriodInput {
  start: DateTime!
  end: DateTime!
}

type Subscription {
  listenForUserAuthentication: UserAuthenticationType!
  listenForUserStatusChanged: UserType!
  listenForUserCreated: UserType!
  listenForLocationRequested(target: TargetACIInput!): TargetIdsType!
  listenForLocationChanged(target: TargetACIInput!): UserLocationType!
  listenForBrandCreated: BrandType!
  listenForCompanyCreated: CompanyType!
  listenForProductCreated: ProductType!
  listenForWholesalerCreated: WholesalerType!
  listenForPOSCategoryCreated: POSCategoryType!
  pointOfSaleCreated: PointOfSaleType!
  listenForManufacturerCreated: ManufacturerType!
  listenForLoyaltyProgramCreated: LoyaltyProgramType!
  listenForFormCreated: FormDtoType!
  listenForResponseCreated: ResponseDtoType!
  listenForOrderCreated(posId: String!): OrderType!
  listenForDeliveryOrderCreated(posId: String!): OrderType!
  listenForCancelProduct(userId: String!): OrderType!
  listenForDeliveryManAssigned(userId: String!): OrderType!
  listenForUpdateProductOrderStatus(userId: String!): OrderType!
  listenForUpdateProductPaymentStatus(userId: String!): OrderType!
  listenForOnsiteConverterPushed(userId: String!): PushAmountResponseType!
  listenForSubscriptionRequest(target: TargetACIInput!): SubscribersFullType!
  listenForSubscriptionReply(userId: String!): SubscribersFullType!
  listenForFollowersCreated(code: String!): FollowerType!
  listenForNewAdhocNotification: NotificationFullType!
  listenForSendAdhocNotificationTest(
    userId: String!
  ): AdhocNotificationTestType!
}